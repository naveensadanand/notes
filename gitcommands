1. init, remote, add, commit, push, pull, branch, checkout.
2. remote
git init
	This will initialize a project and create hidden .git folder.

git remote
	This will help to create, view, delete connections from remote repositary.

	git remote -v : This command will list of remote repositary you have to connect.
	git remote add <name> <URL> : Create a new connection to a remote repository. After adding a remote, you’ll be able to use <name> as a convenient shortcut for <url> in other Git commands.
	git remote rm <name> : Remove the connection to the remote repository called <name>.
	git remote rename <old-name> <new-name> : Rename a remote connection from <old-name> to <new-name>

git add
	This command add changes in the working directory to staging area.
Question on git add:
1. Why git add required?
        1. "git add filename" this command add changes to staging area, and commit command picks what's in the staging area.
        2. Git works by using a "staging" area where you prepare what you are going to bundle together as a commit. So, you decided what set of changes you want to commit (e.g. all or a subset), you add them to the staging area, and then you commit what's in the staging area.
2. How do i remove a file from staging area?
        1. "git reset HEAD mynewfile.txt" or "git reset HEAD -- mynewfile.txt" This command will unstage from the staging area. Your modifications will be kept and the file will once again show up in the modified. If you really wants to delete after unstaging, you can use below command.
        2. "git clean -df mynewfile.txt" This command will remove mynewfile.txt from current directory. If you do not provide file name like "git clean -df" this will remove all unstaged file from working directory. So be careful while using "git clean -df" command.


git commit:
	The git commit takes the staged snapshot and commits it to the project history.
	git commit -m "Start a feature"
	This command will commit or take snapshot of staging area and add it to repository History.

git push:
	"git push <remote> <branch>" : Push the specified branch to <remote>, along with all of the necessary commits and internal objects.

	"git push origin master" : This command specifies that you are pushing to the master branch (the branch on Bitbucket) on origin (the Bitbucket server).

	git push <remote> --force : This results in a non-fast-forward merge. The --force flag overrides this behavior and makes the remote repository’s branch match your local one, deleting any upstream changes that may have occurred since you last pulled.

	"git push <remote> --all": Push all of your local branches to the specified remote.

git pull:
        1. Pull changes from a remote repository.
        2. The git pull command merges the file from your remote repository (Bitbucket) into your local repository with a single command.

Note: We should not use pull blindly, since it will override the changes made locally.


git branch:
	The git branch command lets you create, list, rename, and delete branches.

	"git branch": List all of the branches in your local repository.
	"git branch -a" or all: List both remote-tracking branches and local branches.
	"git branch -r": To view your remote branches.
	"git branch <new-branch>": This will create new branch.
	"git branch -d <branch>":  Delete the specified branch. This is a “safe” operation in that Git prevents you from deleting the branch if it has unmerged changes. 
	"git branch -D <branch>":  Force delete the specified branch, even if it has unmerged changes.
	"git branch -m <branch>":  Rename the current branch to <branch>

What is the need of branch?
        When you want to add a new feature or fix a bug, you spawn a new branch to encapsulate your changes. This makes sure that unstable code is never committed to the main code base, and it gives you the chance to clean up your feature’s history before merging it into the main branch.

What actually branch is, Is the branch represents a seperate storage or directory of container?
        a. Git stores a branch as a reference to a commit. In this sense, a branch represents the tip of a series of commits—it's not a container for commits.


git checkout: git checkout command simply updates the HEAD to point to either the specified branch or commit.
	Its serves 1. Check out file, check out commits, check out branches.	

checkout file:
	1. Checking out a file lets you see an old version of that particular file, leaving the rest of your working directory untouched.
	2. "git checkout a1e8fb5 hello.py" : checking out an old file of commit ID:a1e8fb5 does affect the current state of your repository. with this You can re-commit the old version in a new snapshot (add and commit). Its like revert back to an old version of an individual file.
	3. If you decide you don’t want to keep the old version, you can check out the most recent version with the following: "git checkout HEAD hello.py" since HEAD will point to current branch.

checkout commit:
	1. Checking out a commit makes the entire working directory match that commit. This can be used to view an old state of your project without altering your current state in any way.
	2. "git checkout <commit> <file>"       Check out a previous version of a file. This turns the <file> that resides in the working directory into an exact copy of the one from <commit> and adds it to the staging area.
	3. "git checkout <commit>" : Update all files in the working directory to match the specified commit.This will put you in a detached HEAD state.
        4. Checking out an old commit is a read-only operation. The “current” state of your project remains untouched in the master branch.
        5. During the normal course of development, the HEAD usually points to master or some other local branch, but when you check out a previous commit, HEAD no longer points to a branch—it points directly to a commit. This is called a “detached HEAD” state.

Example: "git checkout a1e8fb5" This makes your working directory match the exact state of the a1e8fb5 commit. You can look at files, compile the project, run tests, and even edit files without worrying about losing the current state of the project.Nothing you do in here will be saved in your repository. To continue developing, you need to get back to the “current” state of your project: "git checkout master".
What is difference between usage of commands "git checkout <commit>" and "git checkout <commit> <file>"?
        "git checkout <commit>": Update all files in the working directory to match the specified commit. This will put you in a detached HEAD state.
        "git checkout <commit> <file>": Check out a previous version of a file. This turns the <file> that resides in the working directory into an exact copy of the one from <commit> and "adds it to the staging area".

checkout branch:
        1. git checkout <existing-branch> : Check out the specified branch, which should have already been created with git branch.

        2. git checkout -b <new-branch>: Create and check out <new-branch>.
        3. git checkout -b <new-branch> <existing-branch>: Same as the above invocation, but base the new branch off of <existing-branch>
        4. git checkout --track origin/<existing-branch>: It will switch to remote branch which is aready part of master branch of remote repository.

Detached HEADs:
	1. If you checkout a commit, it will switch to "detached HEAD".
	2. In detached HEAD you can add the file and commit the file, but you cannot push the changes to Repository. To push the changes you can simply create a branch or move a branch to push the changes to repository.

precautions while branch checkout:
	if your working directory or staging area has uncommitted changes that conflict with the branch you’re checking out, Git won’t let you switch branches. It’s best to have a clean working state when you switch branches. The cleaning can be done using "Stashing and Cleaning".

git merge: The git merge command lets you take the independent lines of development created by git branch and integrate them into a single branch.
--ff
When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge commit. This is the default behavior.

--no-ff
Create a merge commit even when the merge resolves as a fast-forward.

	1. git merge <branch>:  Merge the specified branch into the current branch.
	2. git merge --no-ff <branch> : Merge the specified branch into the current branch, but always generate a merge commit (even if it was a fast-forward merge). This is useful for documenting all merges that occur in your repository. The default behavior of Git is to use fast-forwarding whenever possible. 
	3. git config branch.master.mergeoptions  "--no-ff" this will change default behaviour of merger to --no-ff.
	4. -ff Fast-forward: A fast-forward merge can occur when there is a linear path from the current branch tip to the target branch. i.e Instead of merging the branches, all Git has to do to integrate the histories is move (i.e., “fast forward”) the current branch tip up to the target branch tip. This will not create any merge commit.
	4. 3-Way Merge: This is used in case where master progresses while the feature is in-progress. Used when several developers working on same project.

	5. "git merge --abort": can only be run after the merge has resulted in conflicts. git merge --abort will abort the merge process and try to reconstruct the pre-merge state. 

current branch is "master"
	  A---B---C topic
	 /
    D---E---F---G master

Then "git merge topic" will replay the changes made on the topic branch since it diverged from master (i.e., E) until its current commit (C) on top of master. This will results in new commit along with message of two parent commits and log message from user, master is at H.
	  A---B---C topic
	 /         \
    D---E---F---G---H master


Note: Running git merge with non-trivial uncommitted changes is discouraged.

Merge conflicts:
While merging, amoung the changes made on comman ancestors version, non-overlapping once (i.e you changed the area of file and from other side left the area intact, vice-versa) are incorporated to final results.

Example: if any changes from remote repo, with the help of fetch we can get the remote commit ID.
	git fetch : this command gets the remote commit ID of latest commit made on remote repo.
	From https://github.com/naveensadanand/notes
	8974bdf..0dc73b8  gitLearning -> origin/gitLearning
	Our branch is at Commit ID: 8974bdf and remote is having at 0dc73b8.
Using git checkout "commitID" command we can simply check the changes made in remote commitID if everything is fine we can merge our remote commits with our commit resulting in new commit ID. This is the example of --no-ff.
	git checkout 0dc73b8 : Head moves to commitID and we can see the changes and decide to merge it or not.
	git checkout branch: Head moves to previous branch.
	git merge: merging both commits and creates merge commit.
	git push: once we say git push, it has created new commit ffac4fc as shown below
To https://github.com/naveensadanand/notes.git
   0dc73b8..ffac4fc  gitLearning -> gitLearning

When both sides made changes to the same area, we need to resolve it manually, we can see conflict chunk like this.
<<<<<<< yours:sample.txt
Conflict resolution is hard;
let's go shopping.
=======
Git makes conflict resolution easy.
>>>>>>> theirs:sample.txt

The area where a pair of conflicting changes happened is marked with markers <<<<<<<, =======, and >>>>>>>. The part before the ======= is typically your side, and the part afterwards is typically their side.

After seeing a conflict, you can do two things:
	1. Decide not to merge. The only clean-ups you need are to reset the index file to the HEAD commit to reverse 2. and to clean up working tree changes made by 2. and 3.; git merge --abort can be used for this.
	2. Resolve the conflicts. Git will mark the conflicts in the working tree. Edit the files into shape and git add them to the index. Use git commit to seal the deal.

command flow:
	git fetch
	git checkout CommitID 
	Check the changes, and try to merge.
	git merge
	At this stage it will throw error for merge conflict.
"
Auto-merging otherfile
CONFLICT (content): Merge conflict in otherfile
Automatic merge failed; fix conflicts and then commit the result.
"
	then open file "otherfile" and resolve conflict, and use commit.

	git add
	git commit
	git push	

git fetch:
	1. Fetch branches and/or tags (collectively, "refs") from one or more other repositories, along with the objects necessary to complete their histories. 
	2. Remote-tracking branches are updated.
-all 
fetches all remotes.

-f or --force
When git fetch is used with <rbranch>:<lbranch> refspec, it refuses to update the local branch <lbranch> unless the remote branch <rbranch> it fetches is a descendant of <lbranch>. 
This option (-f) overrides that check.

<repository>
The "remote" repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section GIT URLS below) or the name of a remote.

CONFIGURED REMOTE-TRACKING BRANCHES:
git fetch allows you to configure remote.<repository>.fetch configuration variables. Typically such a variable may look like this:
[remote "origin"]
	fetch = +refs/heads/*:refs/remotes/origin/*

When git fetch is run without specifying what branches and/or tags to fetch on the command line, e.g. git fetch origin or git fetch, remote.<repository>.fetch values are used as the refspecs—​they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the origin (i.e. any ref that matches the left-hand side of the value, refs/heads/*) and update the corresponding remote-tracking branches in the refs/remotes/origin/* hierarchy.

EX: 
	1. git fetch origin
	The above command copies all branches from the remote refs/heads/ namespace and stores them to the local refs/remotes/origin/ namespace
	2. git fetch origin +pu:pu maint:tmp
	This updates (or creates, as necessary) branches pu and tmp in the local repository by fetching from the branches (respectively) pu and maint from the remote repository.
GIT URLS:
	1. Git supports ssh, git, http, and https protocols  (in addition, ftp, and ftps can be used for fetching, but this is inefficient and deprecated; do not use it).

The following syntaxes may be used with them:
	ssh://[user@]host.xz[:port]/path/to/repo.git/
	git://host.xz[:port]/path/to/repo.git/
	http[s]://host.xz[:port]/path/to/repo.git/
	ftp[s]://host.xz[:port]/path/to/repo.git/
	

git pull:
	1. git pull is shorthand for git fetch followed by git merge FETCH_HEAD to merge the retrieved branch heads into the current branch. With --rebase, it runs git rebase instead of git merge.
Assume the following history exists and the current branch is "master":

	  A---B---C master on origin
	 /
    D---E---F---G master
	^
	origin/master in your repository
Then "git pull" will fetch and replay the changes from the remote master branch since it diverged from the local master (i.e., E) until its current commit (C) on top of master and record the result in a new commit (i.e H) along with the names of the two parent commits and a log message from the user describing the changes.

	  A---B---C origin/master
	 /         \
    D---E---F---G---H master

--ff
When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge commit. 

--no-ff
Create a merge commit even when the merge resolves as a fast-forward. 

-r
--rebase[=false|true|preserve|interactive]
	1. When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.
	2. When set to preserve, rebase with the --preserve-merges option passed to git rebase so that locally created merge commits will not be flattened.
	3. When false, merge the current branch into the upstream branch.
	4. When interactive, enable the interactive mode of rebase.


git remote:

-v or --verbose
	1. show remote url after name.

Add a new remote, fetch, and check out a branch from it.
	cmd: git remote
	o/p: origin
	cmd: git branch -r
	o/p:  	origin/HEAD -> origin/master
		origin/clanguage
		origin/detachHeadCheck
  		origin/gitLearning
  		origin/jenkins
		origin/master
	cmd: git remote add staging git://git.kernel.org/.../gregkh/staging.git 
	Above command will add remote repository git://git.kernel.org/.../gregkh/staging.git with name staging.
	cmd: git remote
	o/p: 	origin
		staging
	cmd: git fetch staging
	o/p: 	From git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
	 * [new branch]      master     -> staging/master
	 * [new branch]      staging-linus -> staging/staging-linus
	 * [new branch]      staging-next -> staging/staging-next
	cmd: git branch -r 
	o/p:   	origin/HEAD -> origin/master
		origin/clanguage
		origin/detachHeadCheck
 		origin/gitLearning
  		origin/jenkins
  		origin/master
		staging/master   Here new branch is coming.
	cmd: git checkout -b staging staging/master
	This will create new branch with origin staging, with this we can work further.

Imitate git clone but track only selected branches

$ mkdir project.git
$ cd project.git
$ git init
$ git remote add -f -t master -m master origin git://example.com/git.git/
$ git merge origin


git rebase:
	git-rebase - Reapply commits on top of another base tip

git rebase [-i | --interactive] [options] [--exec <cmd>] [--onto <newbase>]
	[<upstream> [<branch>]]
git rebase [-i | --interactive] [options] [--exec <cmd>] [--onto <newbase>]
	--root [<branch>]
git rebase --continue | --skip | --abort | --edit-todo

	2. <branch> Working branch; defaults to HEAD. If <branch> is specified, git rebase will perform an automatic git checkout <branch> before doing anything else. Otherwise it remains on the current branch.
	3. <upstream>: Upstream branch to compare against. If <upstream> is not specified, the upstream configured in branch.<name>.remote and branch.<name>.merge options will be used and the --fork-point option is assumed. If you are not on any branch and current branch not configured upstream then the rebase will abort.
	4. --onto <newbase> Starting point at which to create the new commits. If the --onto option was supplied, the current branch is reset to <upstream>, or <newbase>. This has the exact same effect as git reset --hard <upstream> (or <newbase>).
	5. All changes made by commits in the current branch but that are not in <upstream> are saved to a temporary area. This is the same set of commits that would be shown by git log <upstream>..HEAD
	6. The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order. 
	7. It is possible that a merge failure will prevent this process from being completely automatic.
	8. After resolving merge failure, we can use command "git rebase --continue"
	9. "git rebase --skip" command can bypass merge failure.
	10. "git rebase --abort": command can be used to checkout original <branch> and remove the .git/rebase-apply working files.
	11. --continue Restart the rebasing process after having resolved a merge conflict.
	


current branch is "topic": As per below graph, topic was branched out from master E, and since both are in progress master is at G and topic is at C.

          A---B---C topic
         /
    D---E---F---G master

git rebase master
git rebase master topic  (combination of git checkout topic and git checkout master).
After running any of above command result would be:
                  A'--B'--C' topic
                 /
    D---E---F---G master
Here the topic now is rebase to master G.
Note: When rebase exit topic will remain the checked-out branch.

rebase --onto
	1. First let’s assume your topic is based on branch next. For example, a feature developed in topic depends on some functionality which is found in next.

    o---o---o---o---o  master
         \
          o---o---o---o---o  next
                           \
                            o---o---o  topic

	2. We want to make topic forked from branch master; for example, because the functionality on which topic depends was merged into the more stable master branch.
    o---o---o---o---o  master
        |            \
        |             o'--o'--o'  topic
         \
          o---o---o---o---o  next

We can get this using the following command:
git rebase --onto master next topic

--onto option is to rebase part of a branch. If we have the following situation:

                            H---I---J topicB
                           /
                  E---F---G  topicA
                 /
    A---B---C---D  master
then the command

git rebase --onto master topicA topicB
would result in:

                 H'--I'--J'  topicB
                /
                | E---F---G  topicA
                |/
    A---B---C---D  master
This is useful when topicB does not depend on topicA.

A range of commits could also be removed with rebase.
	1. A range of commit can be removed using rebase.
	if you have E---F---G---H---I---J  topicA and you want to remove F and G, then use below command
	git rebase --onto topic~5 topic~3 topicA
	Above command results in  E---H'---I'---J'  topicA

conflict case:
	1. You can use git diff to locate the markers (<<<<<<) and make edits to resolve the conflict. For each file you edit, you need to tell Git that the conflict has been resolved, typically this would be done with "git add <filename>"
	2. After resolving the conflict manually and updating the index with the desired resolution, you can continue the rebasing process with "git rebase --continue"
	3. you can undo the git rebase with "git rebase --abort"

