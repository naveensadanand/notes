Getting and Creating Projects: 
    init
    clone
Basic Snapshotting:
    add
    status
    diff
    commit
    reset
    rm
    mv

Branching and Merging
    branch
    checkout
    merge
    mergetool
    log
    stash
    tag

Sharing and Updating Projects
    fetch
    pull
    push
    remote
    submodule

Inspection and Comparison
    show
    log
    diff
    shortlog
    describe

Patching
    apply
    cherry-pick
    diff
    rebase
    revert

Debugging
    bisect
    blame
    grep


1. init, remote, add, commit, push, pull, branch, checkout.
2. remote
git init
	This will initialize a project and create hidden .git folder.

git remote
	This will help to create, view, delete connections from remote repositary.

	git remote -v : This command will list of remote repositary you have to connect.
	git remote add <name> <URL> : Create a new connection to a remote repository. After adding a remote, you’ll be able to use <name> as a convenient shortcut for <url> in other Git commands.
	git remote rm <name> : Remove the connection to the remote repository called <name>.
	git remote rename <old-name> <new-name> : Rename a remote connection from <old-name> to <new-name>

git add
	This command add changes in the working directory to staging area.
Question on git add:
1. Why git add required?
        1. "git add filename" this command add changes to staging area, and commit command picks what's in the staging area.
        2. Git works by using a "staging" area where you prepare what you are going to bundle together as a commit. So, you decided what set of changes you want to commit (e.g. all or a subset), you add them to the staging area, and then you commit what's in the staging area.
2. How do i remove a file from staging area?
        1. "git reset HEAD mynewfile.txt" or "git reset HEAD -- mynewfile.txt" This command will unstage from the staging area. Your modifications will be kept and the file will once again show up in the modified. If you really wants to delete after unstaging, you can use below command.
        2. "git clean -df mynewfile.txt" This command will remove mynewfile.txt from current directory. If you do not provide file name like "git clean -df" this will remove all unstaged file from working directory. So be careful while using "git clean -df" command.


git commit: Record changes to the repository
	The git commit takes the staged snapshot and commits it to the project history.
	git commit -m "Start a feature"
	This command will commit or take snapshot of staging area and add it to repository History.
	git commit --amend -m "New and correct message"
	To change the last commit, you can simply commit again, using the --amend flag.Therefore, use "amend" whenever you want to change / edit your very last and unpushed commit.

git push:
	"git push <remote> <branch>" : Push the specified branch to <remote>, along with all of the necessary commits and internal objects.

	"git push origin master" : This command specifies that you are pushing to the master branch (the branch on Bitbucket) on origin (the Bitbucket server).

	git push <remote> --force : This results in a non-fast-forward merge. The --force flag overrides this behavior and makes the remote repository’s branch match your local one, deleting any upstream changes that may have occurred since you last pulled.

	"git push <remote> --all": Push all of your local branches to the specified remote.
	
	"git push --force": 
git pull:
        1. Pull changes from a remote repository.
        2. The git pull command merges the file from your remote repository (Bitbucket) into your local repository with a single command.

Note: We should not use pull blindly, since it will override the changes made locally.


git branch:
	The git branch command lets you create, list, rename, and delete branches.

	"git branch": List all of the branches in your local repository.
	"git branch -a" or all: List both remote-tracking branches and local branches.
	"git branch -r": To view your remote branches.
	"git branch <new-branch>": This will create new branch.
	"git branch -d <branch>":  Delete the specified branch. This is a “safe” operation in that Git prevents you from deleting the branch if it has unmerged changes. 
	"git branch -D <branch>":  Force delete the specified branch, even if it has unmerged changes.
	"git branch -m <branch>":  Rename the current branch to <branch>

What is the need of branch?
        When you want to add a new feature or fix a bug, you spawn a new branch to encapsulate your changes. This makes sure that unstable code is never committed to the main code base, and it gives you the chance to clean up your feature’s history before merging it into the main branch.

What actually branch is, Is the branch represents a seperate storage or directory of container?
        a. Git stores a branch as a reference to a commit. In this sense, a branch represents the tip of a series of commits—it's not a container for commits.


git checkout: git checkout command simply updates the HEAD to point to either the specified branch or commit.
	Its serves 1. Check out file, check out commits, check out branches.	

checkout file:
	1. Checking out a file lets you see an old version of that particular file, leaving the rest of your working directory untouched.
	2. "git checkout a1e8fb5 hello.py" : checking out an old file of commit ID:a1e8fb5 does affect the current state of your repository. with this You can re-commit the old version in a new snapshot (add and commit). Its like revert back to an old version of an individual file.
	3. If you decide you don’t want to keep the old version, you can check out the most recent version with the following: "git checkout HEAD hello.py" since HEAD will point to current branch.

checkout commit:
	1. Checking out a commit makes the entire working directory match that commit. This can be used to view an old state of your project without altering your current state in any way.
	2. "git checkout <commit> <file>"       Check out a previous version of a file. This turns the <file> that resides in the working directory into an exact copy of the one from <commit> and adds it to the staging area.
	3. "git checkout <commit>" : Update all files in the working directory to match the specified commit.This will put you in a detached HEAD state.
        4. Checking out an old commit is a read-only operation. The “current” state of your project remains untouched in the master branch.
        5. During the normal course of development, the HEAD usually points to master or some other local branch, but when you check out a previous commit, HEAD no longer points to a branch—it points directly to a commit. This is called a “detached HEAD” state.

Example: "git checkout a1e8fb5" This makes your working directory match the exact state of the a1e8fb5 commit. You can look at files, compile the project, run tests, and even edit files without worrying about losing the current state of the project.Nothing you do in here will be saved in your repository. To continue developing, you need to get back to the “current” state of your project: "git checkout master".
What is difference between usage of commands "git checkout <commit>" and "git checkout <commit> <file>"?
        "git checkout <commit>": Update all files in the working directory to match the specified commit. This will put you in a detached HEAD state.
        "git checkout <commit> <file>": Check out a previous version of a file. This turns the <file> that resides in the working directory into an exact copy of the one from <commit> and "adds it to the staging area".

checkout branch:
        1. git checkout <existing-branch> : Check out the specified branch, which should have already been created with git branch.

        2. git checkout -b <new-branch>: Create and check out <new-branch>.
        3. git checkout -b <new-branch> <existing-branch>: Same as the above invocation, but base the new branch off of <existing-branch>
        4. git checkout --track origin/<existing-branch>: It will switch to remote branch which is aready part of master branch of remote repository.

Detached HEADs:
	1. If you checkout a commit, it will switch to "detached HEAD".
	2. In detached HEAD you can add the file and commit the file, but you cannot push the changes to Repository. To push the changes you can simply create a branch or move a branch to push the changes to repository.

precautions while branch checkout:
	if your working directory or staging area has uncommitted changes that conflict with the branch you’re checking out, Git won’t let you switch branches. It’s best to have a clean working state when you switch branches. The cleaning can be done using "Stashing and Cleaning".

git merge: 
	The git merge command lets you take the independent lines of development created by git branch and integrate them into a single branch.
--ff
When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge commit. This is the default behavior.

--no-ff
Create a merge commit even when the merge resolves as a fast-forward.

	1. git merge <branch>:  Merge the specified branch into the current branch.
	2. git merge --no-ff <branch> : Merge the specified branch into the current branch, but always generate a merge commit (even if it was a fast-forward merge). This is useful for documenting all merges that occur in your repository. The default behavior of Git is to use fast-forwarding whenever possible. 
	3. git config branch.master.mergeoptions  "--no-ff" this will change default behaviour of merger to --no-ff.
	4. -ff Fast-forward: A fast-forward merge can occur when there is a linear path from the current branch tip to the target branch. i.e Instead of merging the branches, all Git has to do to integrate the histories is move (i.e., “fast forward”) the current branch tip up to the target branch tip. This will not create any merge commit.
	4. 3-Way Merge: This is used in case where master progresses while the feature is in-progress. Used when several developers working on same project.

	5. "git merge --abort": can only be run after the merge has resulted in conflicts. git merge --abort will abort the merge process and try to reconstruct the pre-merge state. 

current branch is "master"
	  A---B---C topic
	 /
    D---E---F---G master

Then "git merge topic" will replay the changes made on the topic branch since it diverged from master (i.e., E) until its current commit (C) on top of master. This will results in new commit along with message of two parent commits and log message from user, master is at H.
	  A---B---C topic
	 /         \
    D---E---F---G---H master


Note: Running git merge with non-trivial uncommitted changes is discouraged.

Merge conflicts:
While merging, amoung the changes made on comman ancestors version, non-overlapping once (i.e you changed the area of file and from other side left the area intact, vice-versa) are incorporated to final results.

Example: if any changes from remote repo, with the help of fetch we can get the remote commit ID.
	git fetch : this command gets the remote commit ID of latest commit made on remote repo.
	From https://github.com/naveensadanand/notes
	8974bdf..0dc73b8  gitLearning -> origin/gitLearning
	Our branch is at Commit ID: 8974bdf and remote is having at 0dc73b8.
Using git checkout "commitID" command we can simply check the changes made in remote commitID if everything is fine we can merge our remote commits with our commit resulting in new commit ID. This is the example of --no-ff.
	git checkout 0dc73b8 : Head moves to commitID and we can see the changes and decide to merge it or not.
	git checkout branch: Head moves to previous branch.
	git merge: merging both commits and creates merge commit.
	git push: once we say git push, it has created new commit ffac4fc as shown below
To https://github.com/naveensadanand/notes.git
   0dc73b8..ffac4fc  gitLearning -> gitLearning

When both sides made changes to the same area, we need to resolve it manually, we can see conflict chunk like this.
<<<<<<< yours:sample.txt
Conflict resolution is hard;
let's go shopping.
=======
Git makes conflict resolution easy.
>>>>>>> theirs:sample.txt

The area where a pair of conflicting changes happened is marked with markers <<<<<<<, =======, and >>>>>>>. The part before the ======= is typically your side, and the part afterwards is typically their side.

After seeing a conflict, you can do two things:
	1. Decide not to merge. The only clean-ups you need are to reset the index file to the HEAD commit to reverse 2. and to clean up working tree changes made by 2. and 3.; git merge --abort can be used for this.
	2. Resolve the conflicts. Git will mark the conflicts in the working tree. Edit the files into shape and git add them to the index. Use git commit to seal the deal.

command flow:
	git fetch
	git checkout CommitID 
	Check the changes, and try to merge.
	git merge
	At this stage it will throw error for merge conflict.
"
Auto-merging otherfile
CONFLICT (content): Merge conflict in otherfile
Automatic merge failed; fix conflicts and then commit the result.
"
	then open file "otherfile" and resolve conflict, and use commit.

	git add
	git commit
	git push	

git fetch:
	1. Fetch branches and/or tags (collectively, "refs") from one or more other repositories, along with the objects necessary to complete their histories. 
	2. Remote-tracking branches are updated.
-all 
fetches all remotes.

-f or --force
When git fetch is used with <rbranch>:<lbranch> refspec, it refuses to update the local branch <lbranch> unless the remote branch <rbranch> it fetches is a descendant of <lbranch>. 
This option (-f) overrides that check.

<repository>
The "remote" repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section GIT URLS below) or the name of a remote.

CONFIGURED REMOTE-TRACKING BRANCHES:
git fetch allows you to configure remote.<repository>.fetch configuration variables. Typically such a variable may look like this:
[remote "origin"]
	fetch = +refs/heads/*:refs/remotes/origin/*

When git fetch is run without specifying what branches and/or tags to fetch on the command line, e.g. git fetch origin or git fetch, remote.<repository>.fetch values are used as the refspecs—​they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the origin (i.e. any ref that matches the left-hand side of the value, refs/heads/*) and update the corresponding remote-tracking branches in the refs/remotes/origin/* hierarchy.

EX: 
	1. git fetch origin
	The above command copies all branches from the remote refs/heads/ namespace and stores them to the local refs/remotes/origin/ namespace
	2. git fetch origin +pu:pu maint:tmp
	This updates (or creates, as necessary) branches pu and tmp in the local repository by fetching from the branches (respectively) pu and maint from the remote repository.
GIT URLS:
	1. Git supports ssh, git, http, and https protocols  (in addition, ftp, and ftps can be used for fetching, but this is inefficient and deprecated; do not use it).

The following syntaxes may be used with them:
	ssh://[user@]host.xz[:port]/path/to/repo.git/
	git://host.xz[:port]/path/to/repo.git/
	http[s]://host.xz[:port]/path/to/repo.git/
	ftp[s]://host.xz[:port]/path/to/repo.git/
	

git pull:
	1. git pull is shorthand for git fetch followed by git merge FETCH_HEAD to merge the retrieved branch heads into the current branch. With --rebase, it runs git rebase instead of git merge.
Assume the following history exists and the current branch is "master":

	  A---B---C master on origin
	 /
    D---E---F---G master
	^
	origin/master in your repository
Then "git pull" will fetch and replay the changes from the remote master branch since it diverged from the local master (i.e., E) until its current commit (C) on top of master and record the result in a new commit (i.e H) along with the names of the two parent commits and a log message from the user describing the changes.

	  A---B---C origin/master
	 /         \
    D---E---F---G---H master

--ff
When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge commit. 

--no-ff
Create a merge commit even when the merge resolves as a fast-forward. 

-r
--rebase[=false|true|preserve|interactive]
	1. When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.
	2. When set to preserve, rebase with the --preserve-merges option passed to git rebase so that locally created merge commits will not be flattened.
	3. When false, merge the current branch into the upstream branch.
	4. When interactive, enable the interactive mode of rebase.


git remote:

-v or --verbose
	1. show remote url after name.

Add a new remote, fetch, and check out a branch from it.
	cmd: git remote
	o/p: origin
	cmd: git branch -r
	o/p:  	origin/HEAD -> origin/master
		origin/clanguage
		origin/detachHeadCheck
  		origin/gitLearning
  		origin/jenkins
		origin/master
	cmd: git remote add staging git://git.kernel.org/.../gregkh/staging.git 
	Above command will add remote repository git://git.kernel.org/.../gregkh/staging.git with name staging.
	cmd: git remote
	o/p: 	origin
		staging
	cmd: git fetch staging
	o/p: 	From git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
	 * [new branch]      master     -> staging/master
	 * [new branch]      staging-linus -> staging/staging-linus
	 * [new branch]      staging-next -> staging/staging-next
	cmd: git branch -r 
	o/p:   	origin/HEAD -> origin/master
		origin/clanguage
		origin/detachHeadCheck
 		origin/gitLearning
  		origin/jenkins
  		origin/master
		staging/master   Here new branch is coming.
	cmd: git checkout -b staging staging/master
	This will create new branch with origin staging, with this we can work further.

Imitate git clone but track only selected branches

$ mkdir project.git
$ cd project.git
$ git init
$ git remote add -f -t master -m master origin git://example.com/git.git/
$ git merge origin


git rebase:
	git-rebase - Reapply commits on top of another base tip

git rebase [-i | --interactive] [options] [--exec <cmd>] [--onto <newbase>]
	[<upstream> [<branch>]]
git rebase [-i | --interactive] [options] [--exec <cmd>] [--onto <newbase>]
	--root [<branch>]
git rebase --continue | --skip | --abort | --edit-todo

	2. <branch> Working branch; defaults to HEAD. If <branch> is specified, git rebase will perform an automatic git checkout <branch> before doing anything else. Otherwise it remains on the current branch.
	3. <upstream>: Upstream branch to compare against. If <upstream> is not specified, the upstream configured in branch.<name>.remote and branch.<name>.merge options will be used and the --fork-point option is assumed. If you are not on any branch and current branch not configured upstream then the rebase will abort.
	4. --onto <newbase> Starting point at which to create the new commits. If the --onto option was supplied, the current branch is reset to <upstream>, or <newbase>. This has the exact same effect as git reset --hard <upstream> (or <newbase>).
	5. All changes made by commits in the current branch but that are not in <upstream> are saved to a temporary area. This is the same set of commits that would be shown by git log <upstream>..HEAD
	6. The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order. 
	7. It is possible that a merge failure will prevent this process from being completely automatic.
	8. After resolving merge failure, we can use command "git rebase --continue"
	9. "git rebase --skip" command can bypass merge failure.
	10. "git rebase --abort": command can be used to checkout original <branch> and remove the .git/rebase-apply working files.
	11. --continue Restart the rebasing process after having resolved a merge conflict.
	12. --no-ff With --interactive, cherry-pick all rebased commits instead of fast-forwarding over the unchanged ones. This ensures that the entire history of the rebased branch is composed of new commits.
	13. --autostash --no-autostash: Automatically create a temporary stash before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts.
	14. --root: Rebase all commits reachable from <branch>, instead of limiting them with an <upstream>. This allows you to rebase the root commit(s) on a branch. 


current branch is "topic": As per below graph, topic was branched out from master E, and since both are in progress master is at G and topic is at C.

          A---B---C topic
         /
    D---E---F---G master

git rebase master
git rebase master topic  (combination of git checkout topic and git checkout master).
After running any of above command result would be:
                  A'--B'--C' topic
                 /
    D---E---F---G master
Here the topic now is rebase to master G.
Note: When rebase exit topic will remain the checked-out branch.

rebase --onto
	1. First let’s assume your topic is based on branch next. For example, a feature developed in topic depends on some functionality which is found in next.

    o---o---o---o---o  master
         \
          o---o---o---o---o  next
                           \
                            o---o---o  topic

	2. We want to make topic forked from branch master; for example, because the functionality on which topic depends was merged into the more stable master branch.
    o---o---o---o---o  master
        |            \
        |             o'--o'--o'  topic
         \
          o---o---o---o---o  next

We can get this using the following command:
git rebase --onto master next topic

--onto option is to rebase part of a branch. If we have the following situation:

                            H---I---J topicB
                           /
                  E---F---G  topicA
                 /
    A---B---C---D  master
then the command

git rebase --onto master topicA topicB
would result in:

                 H'--I'--J'  topicB
                /
                | E---F---G  topicA
                |/
    A---B---C---D  master
This is useful when topicB does not depend on topicA.

A range of commits could also be removed with rebase.
	1. A range of commit can be removed using rebase.
	if you have E---F---G---H---I---J  topicA and you want to remove F and G, then use below command
	git rebase --onto topic~5 topic~3 topicA
	Above command results in  E---H'---I'---J'  topicA

conflict case:
	1. You can use git diff to locate the markers (<<<<<<) and make edits to resolve the conflict. For each file you edit, you need to tell Git that the conflict has been resolved, typically this would be done with "git add <filename>"
	2. After resolving the conflict manually and updating the index with the desired resolution, you can continue the rebasing process with "git rebase --continue"
	3. you can undo the git rebase with "git rebase --abort"



What is the difference between merge and rebase?
Merge:
current branch is "master"
          A---B---C topic
         /
    D---E---F---G master

Then "git merge topic" will replay the changes made on the topic branch since it diverged from master (i.e., E) until its current commit (C) on top of master. This will results in new commit along with message of two parent commits and log message from user, master is at H.

Here performs a three-way merge between the two latest branch snapshots (G and C) and the most recent common ancestor of the two (E), creating a new snapshot (and commit) H.
          A---B---C topic
         /         \
    D---E---F---G---H master

$ git checkout master
$ git merge experiment

rebase:
However, there is another way: you can take the patch of the change that was introduced in C and reapply it on top of G.

        A---B---C topic
                 \
     D---E---F---G 
		   master
In this example, you’d run the following:
$ git checkout experiment
$ git rebase master
At this point, you can go back to the master branch and do a fast-forward merge.
$ git checkout master
$ git merge experiment
	
		Master
          A---B---C' topic
                   \
    D---E---F---G---H 
                   
Now, the snapshot pointed to by C' is exactly the same as the one that was pointed to by H in the above merge example. Here both master and topic branch pointing to C'.


There is no difference in the end product of the integration, but rebasing makes for a cleaner history. If you examine the log of a rebased branch, it looks like a linear history: it appears that all the work happened in series, even when it originally happened in parallel. Often, you’ll do this to make sure your commits apply cleanly on a remote branch.

More Interesting Rebases:
You branched a topic branch (server) to add some server-side functionality to your project, and made a commit. Then, you branched off that to make the client-side changes (client) and committed a few times. Finally, you went back to your server branch and did a few more commits.

	     	     Master
C1 <-- C2 <-- C5 <-- C6
      \
      C3 <-- C4 <-- C10
       \	   Server
	C8 <-- C9
	      Client
Figure: A history with a topic branch(C8) off another topic branch(C3).
Suppose you decide that you want to merge your client-side changes into your mainline for a release, but you want to hold off on the server-side changes until it’s tested further. 
You can take changes of clinet C8 and C9 which is not present in Server, and replay them on your master branch by using the --onto option of git rebase:

$ git rebase --onto master server client
This basically says, “Take the client branch, figure out the patches since it diverged from the server branch, and replay these patches in the client branch to master.

                     Master
C1 <-- C2 <-- C5 <-- C6 <-- C8' <-- C9'
      \				   Client
      C3 <-- C4 <-- C10
       \           Server

Figure: Rebasing a topic branch(C8) off another topic branch(C3).

Now you can fast-forward your master branch:
$ git checkout master
$ git merge client
 		                   Master
C1 <-- C2 <-- C5 <-- C6 <-- C8' <-- C9'
      \                            Client
      C3 <-- C4 <-- C10
       \           Server

Figure. Fast-forwarding your master branch to include the client branch changes


Let’s say you decide to pull in your server branch as well. 
ou can rebase the server branch onto the master branch without having to check it out first by running git rebase [basebranch] [topicbranch] – which checks out the topic branch (in this case, server) for you and replays it onto the base branch (master):

$ git rebase master server   #This command equals to "git checkout server" and "git rebase master"

This replays your server work on top of your master work.

                                   Master
C1 <-- C2 <-- C5 <-- C6 <-- C8' <-- C9' <-- C3' <-- C4' <-- C10'
      \                            Client    		   server

Figure. Rebasing your server branch on top of your master branch

Then, you can fast-forward the base branch (master):

$ git checkout master
$ git merge server

You can remove the client and server branches.
$ git branch -d client
$ git branch -d server

                                   			   Master
C1 <-- C2 <-- C5 <-- C6 <-- C8' <-- C9' <-- C3' <-- C4' <-- C10'

Figure. Final commit history

Note: Do not rebase commits that exist outside your repository.
In general the way to get the best of both worlds is to rebase local changes you’ve made but haven’t shared yet before you push them in order to clean up your story, but never rebase anything you’ve pushed somewhere. 
You should also be able to share your branches by pushing them to a shared server, working with others on shared branches and rebasing your branches before they are shared.

git stash:
	1. Use git stash when you want to record the current state of the working directory and the index, but want to go back to a clean working directory.
	Calling git stash without any arguments is equivalent to git stash save.
	2. Note that the stash is local to your Git repository.
        3. "git stash list": List the stashes that you currently have. Its also list the name of branch, and commitID with commit message.
        stash@{0}: WIP on newbranch: eefbdc0 file5

git stash pop
        Popping your stash removes the changes from your stash and reapplies them to your working copy.
git stash apply
        You can reapply the changes to your working copy and keep them in your stash with "git stash apply". This is useful if you want to apply the same stashed changes to multiple branches.

Stashing untracked or ignored files:
a. By default, running git stash will stash.
        1. changes that have been added to your index (staged changes)
        2. changes made to files that are currently tracked by Git (unstaged changes).
b. But it will not stash:
        1. New files in your working copy that have not yet been staged.
        2. Files that have been ignored.

Adding the -u option (or --include-untracked) tells git stash to also stash your untracked files:

"git stash -u"  or  "git stash --include-untracked"

You can include changes to ignored files as well by passing the -a option (or --all) when running git stash.

"git stash -a" or "git stash -all"

Managing multiple stashes
        1. We can create stash several times to create multiple stashes, can can be view by command "git stash list".
        2. It's good practice to annotate your stashes with a description, using git stash save "message for readability":

$ git stash save "add style to our site"
Saved working directory and index state On master: add style to our site
HEAD is now at 5002d47 our new homepage

$ git stash list
stash@{0}: On master: add style to our site
stash@{1}: WIP on master: 5002d47 our new homepage
stash@{2}: WIP on master: 5002d47 our new homepage

By default, git stash pop will re-apply the most recently created stash: stash@{0}
You can choose which stash to re-apply by passing its identifier as the last argument, for example:
$ git stash pop stash@{2}


Viewing stash diffs:
        1. "git stash show": You can view a summary of a stash with "git stash show".
        2. Or pass the -p option (or --patch) to view the full diff of a stash "git stash -p" or "git stash --patch". You can also use this command to choose to stash just a single file, a collection of files, or individual changes from within files.

Cleaning up your stash:
        1. You can delete it with "git stash drop".
        2. You can delete all of your stashes using command "git stash clear"


.gitignore
Git sees every file in your working copy as one of three things:
        1. tracked - a file which has been previously staged or committed;
        2. untracked - a file which has not been staged or committed; or
        3. ignored - a file which Git has been explicitly told to ignore.
You can add file manually.
vi ~/.gitignore
# ignore all logs
*.log
#ignore object files
*.o
#ignore .gitignore file in local repository.
.gitignore

Ignored files are usually build artifacts and machine generated files that can be derived from your repository source or should otherwise not be committed.
Some common examples are:
        1. dependency caches, such as the contents of /node_modules or /packages
        2. compiled code, such as .o, .pyc, and .class files
        3. build output directories, such as /bin, /out, or /target
        4. files generated at runtime, such as .log, .lock, or .tmp
        5. hidden system files, such as .DS_Store or Thumbs.db
        6. personal IDE config files, such as .idea/workspace.xml

.gitignore file can be created locally. This will ignore file for your local repository you are working on.


Global Git ignore rules:
        In addition, you can define global Git ignore patterns for all repositories on your local system by setting the Git core.excludesFile property.
        "git config --global core.excludesFile ~/.gitignore" This command will add rule to excludesFile from /home/naveen/.gitignore

Ignoring a previously committed file:
        1. If you want to ignore a file that you've committed in the past, you'll need to delete the file from your repository and then add a .gitignore rule for it.
        2. Using the --cached option with git rm means that the file will be deleted from your repository history, but will remain in your working directory as an ignored file.

Example:
$ echo debug.log >> .gitignore

$ git rm --cached debug.log
rm 'debug.log'

$ git commit -m "Start ignoring debug.log"
Note: You can omit the --cached option if you want to delete the file from both the repository and your local file system.

Committing an ignored file:
        1. We have a pattern called .log in .gitignore file, but is you want to commit build.log file, you can give exception to build.log file in .gitignore file.
This can be achieve by two ways using -f option to add a file and we can give negation in .gitignore file.

        Example1: git add -f debug.log
                  git commit -m "Force adding debug.log"

        Example2: open .gitignore file and add !debug.log, with this you can do normal commit.
                git add debug.log
                git commit -m "Adding debug.log"
.gitignore and stash:
        1. by default git stash ignores ignored files and only stashes changes to files that are tracked by Git. However, you can invoke git stash with the --all option to stash changes to ignored and untracked files as well.

Debugging .gitignore files:
        1. If you have complicated .gitignore patterns, or patterns spread over multiple .gitignore files, it can be difficult to track down "why a particular file is being ignored".
        2. You can use the git check-ignore command with the -v (or --verbose) option to determine which pattern is causing a particular file to be ignored:
        "<file containing the pattern> : <line number of the pattern> : <pattern>    <file name>"
Example: "git check-ignore -v debug.log"
        .gitignore:3:*.log  debug.log


git clone
git clone <repo> <dir>
	1. Clones a repository into a newly created directory, creates remote-tracking branches for each branch in the cloned repository (visible using git branch -r), and creates and checks out an initial branch that is forked from the cloned repository’s currently active branch.
	2. After clone a plain git fetch without arguments will update all the remote-tracking branches, and a git pull without arguments will in addition merge the remote master branch into the current master branch.
	step1: git clone URL <dir> #this command creates a directory <dir> and clone the remote repository through URL into the <dir>.
	step2: git fetch: This command without arguments will update all the remote-tracking branches.
	step3: git pull: This command without arguments will in addition merge the remote master branch into the current master branch.
	3. While cloning if we give "--single-branch" then it will clone only master branch, so step2 and step3 can be ignored.

-l or --local
When the repository to clone from is on a local machine.
If the repository is specified as a local path (e.g., /path/to/repo), this is the default.
If the repository is specified as a URL, then this flag is ignored 

If the reference repository is on the local machine, automatically setup .git/objects/info/alternates to obtain objects from the reference repository. Using an already existing repository as an alternate will require fewer objects to be copied from the repository being cloned, reducing network and local storage costs.

GIT URLS
In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent.
The following syntaxes may be used with them:

ssh://[user@]host.xz[:port]/path/to/repo.git/

git://host.xz[:port]/path/to/repo.git/

http[s]://host.xz[:port]/path/to/repo.git/

ftp[s]://host.xz[:port]/path/to/repo.git/

Examples:
Clone from upstream:
$ git clone git://git.kernel.org/pub/scm/.../linux.git my-linux
$ cd my-linux
$ make


Make a local clone that borrows from the current directory, without checking things out:
$ git clone -l -s -n . ../copy
$ cd ../copy
$ git show-branch

Clone from upstream while borrowing from an existing local directory:

$ git clone --reference /git/linux.git 	git://git.kernel.org/pub/scm/.../linux.git my-linux
$ cd my-linux

Create a bare repository to publish your changes to the public:
$ git clone --bare -l /home/proj/.git /pub/scm/proj.git

git revert:
	1.  git revert is used to record some new commits to reverse the effect of some earlier commits.
-e or --edit
	With this option, git revert will let you edit the commit message prior to committing the revert.
--continue
Continue the operation in progress using the information in .git/sequencer. Can be used to continue after resolving conflicts in a failed cherry-pick or revert.
--quit
Forget about the current operation in progress. Can be used to clear the sequencer state after a failed cherry-pick or revert.
--abort
Cancel the operation and return to the pre-sequence state.

EXAMPLES
git revert HEAD~3
	Revert the changes specified by the fourth last commit in HEAD and create a new commit with the reverted changes.

git revert -n master~5..master~2
	Revert the changes done by commits from the fifth last commit in master (included) to the third last commit in master (included), but do not create any commit with the reverted changes. The revert only modifies the working tree and the index.

git revert <commit>
        1. Generate a new commit that undoes all of the changes introduced in <commit>, then apply it to the current branch.
        2. This can be useful, for example, if you’re tracking down a bug and find that it was introduced by a single commit. Instead of manually going in, fixing it, and committing a new snapshot, you can use git revert to automatically do all of this for you.

git revert HEAD
	Revert the commit we just created.

git reset:
git reset
        1. If git revert is a “safe” way to undo changes, you can think of git reset as the dangerous method.
        2. When you undo with git reset(and the commits are no longer referenced by any ref or the reflog), there is no way to retrieve the original copy—it is a permanent undo.

        "git reset <file>"
        Remove the specified file from the staging area, but leave the working directory unchanged.
        "git reset"
        Reset the staging area to match the most recent commit, but leave the working directory unchanged, This unstages all files without overwriting any changes, giving you the opportunity to re-build the staged snapshot from scratch.
        "git reset --hard"
        Reset the staging area and the working directory to match the most recent commit. In addition to unstaging changes, the --hard flag tells Git to overwrite all changes in the working directory,too.

        "git reset <commit>"
        Move the current branch tip backward to <commit>, reset the staging area to match, but leave the working directory alone.
        "git reset --hard <commit>"
        Move the current branch tip backward to <commit> and reset both the staging area and the working directory to match.

Examples:
Unstaging a File
# Edit both hello.py and main.py

# Stage everything in the current directory
git add .

# Realize that the changes in hello.py and main.py
# should be committed in different snapshots

# Unstage main.py
git reset main.py

# Commit only hello.py
git commit -m "Make some changes to hello.py"

# Commit main.py in a separate snapshot
git add main.py
git commit -m "Edit main.py"

Removing Local Commits
# Create a new file called `foo.py` and add some code to it

# Commit it to the project history
git add foo.py
git commit -m "Start developing a crazy feature"

# Edit `foo.py` again and change some other tracked files, too

# Commit another snapshot
git commit -a -m "Continue my crazy feature"

# Decide to scrap the feature and remove the associated commits
git reset --hard HEAD~2
	The git reset HEAD~2 command moves the current branch backward by two commits, effectively removing the two snapshots we just created from the project history.


git clean

The git clean command removes untracked files from your working directory.

        "git clean -n"
        This will show you which files are going to be removed without actually doing it, i.e it will not remove.
        "git clean -f"
        Remove untracked files from the current directory. The -f (force) flag is required unless the clean.requireForce configuration option is set to false (it's true by default).
        This will not remove untracked folders or files specified by .gitignore.
        "git clean -f <path>"
        Remove untracked files, but limit the operation to the specified path.
        "git clean -df"
        Remove untracked files and untracked directories from the current directory.
        "git clean -xf"
        Remove untracked files from the current directory as well as any files that Git usually ignores.

Note: The git clean command can also be useful for cleaning up the working directory after a build. For example, it can easily remove the .o and .exe binaries generated by a C compiler. This is occasionally a necessary step before packaging a project for release. The -x option is particularly convenient for this purpose.

Example:
# Edit some existing files
# Add some new files
# Realize you have no idea what you're doing

# Undo changes in tracked files
git reset --hard

# Remove untracked files
git clean -df
After running this reset/clean sequence, the working directory and the staging area will look exactly like the most recent commit, and git status will report a clean working directory. You're now ready to begin again.

git log:
        1. The git log command displays committed snapshots. The git log command is Git's basic tool for exploring a repository’s history.
        2. This command will give detail information of repository. It will give detail information like
commit ID/object, auther, Date and Git commit message as well.

Limiting log:
        Limit the number of commits by <limit>. For example, git log -n 3 will display only 3 commits.
        "git log -n <limit>"
        "git log --oneline" This command will give one line information of each commit message.

        "git log <file>" Only display commits that include the specified file.
        "git log --stat" This command include which files were altered and the relative number of lines that were added or deleted from each of them.
        "git log -p" Display the patch representing each commit. This shows the full diff of each commit.
        "git log --author="<pattern>" " Search for commits by a particular author. The <pattern> argument can be a plain string or a regular expression.
        "git log --grep="<pattern>" " Search for commits with a commit message that matches <pattern>, which can be a plain string or a regular expression.
        "git log <since>..<until>" Show only commits that occur between <since> and <until>. Both arguments can be either a commit ID, a branch name, HEAD, or any other kind of revision reference.
	"git log --pretty=oneline"
        "git reflog"
Example:
git log
commit 3157ee3718e180a9476bf2e5cab8e3f1e78a73b7
Author: John Smith

The 40-character string after commit is an SHA-1 checksum of the commit’s contents. This serves two purposes. First, it ensures the integrity of the commit—if it was ever corrupted, the commit would generate a different checksum. Second, it serves as a unique ID for the commit.

The ~ character is useful for making relative references to the parent of a commit. For example, 3157e~1 refers to the commit before 3157e, and HEAD~3 is the great-grandparent of the current commit.

This ID can be used in commands like git log <since>..<until> to refer to specific commits. For instance, git log 3157e..5ab91 will display everything between the commits with ID's 3157e and 5ab91.

        "git log --author="John Smith" -p hello.py" This will display a full diff of all the changes John Smith has made to the file hello.py.

..
        The .. syntax is a very useful tool for comparing branches. The next example displays a brief overview of all the commits that are in some-feature that are not in master.
        "git log --oneline master..some-feature"

Question: What is difference between git status and git log?
        1. "git status" lets you inspect the working directory and the staging area
        2. "git log" only operates on the committed history.

git status:
        1. The git status command displays the state of the working directory and the staging area. It lets you see which changes have been staged, which haven’t, and which files aren’t being tracked by Git.
        2. Its give information of what's been going on with git add and git commit. Status messages also include relevant instructions for staging/unstaging files.
        3. It gives the information of the branch to which git is currently pointing to.
        4. It gives the list of information of files which are needs to be get add using "git add". The file is untracked, meaning that Git sees a file not part of a previous commit.
        5. If the file gets added then it will give list of files that needs to be commit "git commit filename".
        6. Merge conflict information.

squash:
	With git it’s possible to squash previous commits into one. This is a great way to group certain changes together before sharing them with others. ~ Here’s how to squash some commits into one. 
Example: 
git log
* df71a27 - (HEAD feature_x) Updated CSS for new elements (4 minutes ago)
* ba9dd9a - Added new elements to page design (15 minutes ago)
* f392171 - Added new feature X (1 day ago)
* d7322aa - (origin/feature_x) Proof of concept for feature X (3 days ago)

You have a branch feature_x here. You’ve already pushed d7322aa with the proof of concept of the new feature X. After that you’ve been working to add new element to the feature, including some changes in CSS. Now, you want to squash your last three commits in one to make your history look pretty.

The command to accomplish that is:

git rebase -i HEAD~3
This will open up your editor with the following:

pick f392171 Added new feature X
pick ba9dd9a Added new elements to page design
pick df71a27 Updated CSS for new elements
Now you can tell git what to do with each commit. Let’s keep the commit f392171, the one were we added our feature. We’ll squash the following two commits into the first one - leaving us with one clean commit with features X in it, including the added element and CSS.

Change your file to this:

pick f392171 Added new feature X
squash ba9dd9a Added new elements to page design
squash df71a27 Updated CSS for new elements
When done, save and quit your editor. Git will now squash the commits into one. All done!

Note: do not squash commits that you’ve already shared with others. You’re changing history and it will cause trouble for others.



cherry pick:
	1. Cherry picking in Git is designed to apply some commit from one branch into another branch. Cherry picking in git means to choose a commit from one branch and apply it onto another. 

dd2e86 - 946992 - 9143a9 - a6fd86 - 5a6057 [master]
           \
            76cada - 62ecb3 - b886a0 [feature]

Let’s say you’ve written some code in commit 62ecb3 of the feature branch that is very important right now. It may contain a bug fix or code that other people need to have access to now. Whatever the reason, you want to have commit 62ecb3 in the master branch right now, but not the other code you’ve written in the feature branch. ~ Here comes git cherry-pick. In this case, 62ecb3 is the cherry and you want to pick it!

git checkout master
git cherry-pick 62ecb3

That’s all. 62ecb3 is now applied to the master branch and commited (as a new commit) in master. cherry-pick behaves just like merge. If git can’t apply the changes (e.g. you get merge conflicts), git leaves you to resolve the conflicts manually and make the commit yourself.

	2. Cherry picking a range of commits:
In some cases picking one single commit is not enough. You need, let’s say three consecutive commits. cherry-pick is not the right tool for this. rebase is. From the previous example, you’d want commit 76cada and 62ecb3 in master.

The flow is to first create a new branch from feature at the last commit you want, in this case 62ecb3.

git checkout -b newbranch 62ecb3

Next up, you rebase the newbranch commit --onto master. The 76cada^ indicates that you want to start from that specific commit.

git rebase --onto master 76cada^

The result is that commits 76cada through 62ecb3 are applied to master.


git tag:
	a. Git has the ability to tag specific points in history as being important. Typically people use this functionality to mark release points (v1.0, and so on).
	b. git tag: This command lists the tags in alphabetical order; the order in which they appear has no real importance.
	c. you can see the tag data using "git show tagname" command.
	d. You can also search for tags with a particular pattern. The Git source repo, for instance, contains more than 500 tags. If you’re only interested in looking at the 1.8.5 series, you can run this:
$ git tag -l "v1.8.5*"

Creating Tags: Git uses two main types of tags: lightweight and annotated.
	1. A lightweight tag is very much like a branch that doesn’t change – it’s just a pointer to a specific commit.
	2. Annotated tags, however, are stored as full objects in the Git database. They’re checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG). It’s generally recommended that you create annotated tags so you can have all this information.

Annotated Tags:
	1. For creating Annotated tag we need specify -a
	git tag -a v1.0 -m "my version 1.0"
	The -m specifies a tagging message, which is stored with the tag. If you don’t specify a message for an annotated tag, Git launches your editor so you can type it in.
	2. git show v1.0
tag v1.4
Tagger: Ben Straub <ben@straub.cc>
Date:   Sat May 3 20:19:12 2014 -0700

my version 1.4

commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

That shows the tagger information, the date the commit was tagged, and the annotation message before showing the commit information.

Lightweight Tags
Another way to tag commits is with a lightweight tag. This is basically the commit checksum stored in a file – no other information is kept. To create a lightweight tag, don’t supply the -a, -s, or -m option:
$ git tag v1.4-lw

 if you run git show on the tag, you don’t see the extra tag information. The command just shows the commit:

$ git show v1.4-lw
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

Tagging Later

You can also tag commits after you’ve moved past them. Suppose your commit history looks like this:

$ git log --pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme

Now, suppose you forgot to tag the project at v1.2, which was at the “updated rakefile” commit.
You can add it after the fact. To tag that commit, you specify the commit checksum (or part of it) at the end of the command:

$ git tag -a v1.2 9fceb02
$ git show v1.2
tag v1.2
Tagger: Scott Chacon <schacon@gee-mail.com>
Date:   Mon Feb 9 15:32:16 2009 -0800

version 1.2
commit 9fceb02d0ae598e95dc970b74767f19372d61af8
Author: Magnus Chacon <mchacon@gee-mail.com>
Date:   Sun Apr 27 20:43:35 2008 -0700

    updated rakefile

Sharing Tags

By default, the git push command doesn’t transfer tags to remote servers. You will have to explicitly push tags to a shared server after you have created them. 
This process is just like sharing remote branches – you can run git push origin [tagname].
EX: git push origin v1.5

If you have a lot of tags that you want to push up at once, you can also use the --tags option to the git push command.
EX: $ git push origin --tags

Now, when someone else clones or pulls from your repository, they will get all your tags as well.


Checking out Tags:
You can’t really check out a tag in Git, since they can’t be moved around. If you want to put a version of your repository in your working directory that looks like a specific tag, you can create a new branch at a specific tag with git checkout -b [branchname] [tagname]:



$ git checkout -b version2 v2.0.0
Switched to a new branch 'version2'

Of course if you do this and do a commit, your version2 branch will be slightly different than your v2.0.0 tag since it will move forward with your new changes, so do be careful.




