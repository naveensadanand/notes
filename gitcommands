1. init, remote, add, commit, push, pull, branch, checkout.
2. remote
git init
	This will initialize a project and create hidden .git folder.

git remote
	This will help to create, view, delete connections from remote repositary.

	git remote -v : This command will list of remote repositary you have to connect.
	git remote add <name> <URL> : Create a new connection to a remote repository. After adding a remote, you’ll be able to use <name> as a convenient shortcut for <url> in other Git commands.
	git remote rm <name> : Remove the connection to the remote repository called <name>.
	git remote rename <old-name> <new-name> : Rename a remote connection from <old-name> to <new-name>

git add
	This command add changes in the working directory to staging area.
Question on git add:
1. Why git add required?
        1. "git add filename" this command add changes to staging area, and commit command picks what's in the staging area.
        2. Git works by using a "staging" area where you prepare what you are going to bundle together as a commit. So, you decided what set of changes you want to commit (e.g. all or a subset), you add them to the staging area, and then you commit what's in the staging area.
2. How do i remove a file from staging area?
        1. "git reset HEAD mynewfile.txt" or "git reset HEAD -- mynewfile.txt" This command will unstage from the staging area. Your modifications will be kept and the file will once again show up in the modified. If you really wants to delete after unstaging, you can use below command.
        2. "git clean -df mynewfile.txt" This command will remove mynewfile.txt from current directory. If you do not provide file name like "git clean -df" this will remove all unstaged file from working directory. So be careful while using "git clean -df" command.


git commit:
	The git commit takes the staged snapshot and commits it to the project history.
	git commit -m "Start a feature"
	This command will commit or take snapshot of staging area and add it to repository History.

git push:
	"git push <remote> <branch>" : Push the specified branch to <remote>, along with all of the necessary commits and internal objects.

	"git push origin master" : This command specifies that you are pushing to the master branch (the branch on Bitbucket) on origin (the Bitbucket server).

	git push <remote> --force : This results in a non-fast-forward merge. The --force flag overrides this behavior and makes the remote repository’s branch match your local one, deleting any upstream changes that may have occurred since you last pulled.

	"git push <remote> --all": Push all of your local branches to the specified remote.
	
	"git push --force": 
git pull:
        1. Pull changes from a remote repository.
        2. The git pull command merges the file from your remote repository (Bitbucket) into your local repository with a single command.

Note: We should not use pull blindly, since it will override the changes made locally.


git branch:
	The git branch command lets you create, list, rename, and delete branches.

	"git branch": List all of the branches in your local repository.
	"git branch -a" or all: List both remote-tracking branches and local branches.
	"git branch -r": To view your remote branches.
	"git branch <new-branch>": This will create new branch.
	"git branch -d <branch>":  Delete the specified branch. This is a “safe” operation in that Git prevents you from deleting the branch if it has unmerged changes. 
	"git branch -D <branch>":  Force delete the specified branch, even if it has unmerged changes.
	"git branch -m <branch>":  Rename the current branch to <branch>

What is the need of branch?
        When you want to add a new feature or fix a bug, you spawn a new branch to encapsulate your changes. This makes sure that unstable code is never committed to the main code base, and it gives you the chance to clean up your feature’s history before merging it into the main branch.

What actually branch is, Is the branch represents a seperate storage or directory of container?
        a. Git stores a branch as a reference to a commit. In this sense, a branch represents the tip of a series of commits—it's not a container for commits.


git checkout: git checkout command simply updates the HEAD to point to either the specified branch or commit.
	Its serves 1. Check out file, check out commits, check out branches.	

checkout file:
	1. Checking out a file lets you see an old version of that particular file, leaving the rest of your working directory untouched.
	2. "git checkout a1e8fb5 hello.py" : checking out an old file of commit ID:a1e8fb5 does affect the current state of your repository. with this You can re-commit the old version in a new snapshot (add and commit). Its like revert back to an old version of an individual file.
	3. If you decide you don’t want to keep the old version, you can check out the most recent version with the following: "git checkout HEAD hello.py" since HEAD will point to current branch.

checkout commit:
	1. Checking out a commit makes the entire working directory match that commit. This can be used to view an old state of your project without altering your current state in any way.
	2. "git checkout <commit> <file>"       Check out a previous version of a file. This turns the <file> that resides in the working directory into an exact copy of the one from <commit> and adds it to the staging area.
	3. "git checkout <commit>" : Update all files in the working directory to match the specified commit.This will put you in a detached HEAD state.
        4. Checking out an old commit is a read-only operation. The “current” state of your project remains untouched in the master branch.
        5. During the normal course of development, the HEAD usually points to master or some other local branch, but when you check out a previous commit, HEAD no longer points to a branch—it points directly to a commit. This is called a “detached HEAD” state.

Example: "git checkout a1e8fb5" This makes your working directory match the exact state of the a1e8fb5 commit. You can look at files, compile the project, run tests, and even edit files without worrying about losing the current state of the project.Nothing you do in here will be saved in your repository. To continue developing, you need to get back to the “current” state of your project: "git checkout master".
What is difference between usage of commands "git checkout <commit>" and "git checkout <commit> <file>"?
        "git checkout <commit>": Update all files in the working directory to match the specified commit. This will put you in a detached HEAD state.
        "git checkout <commit> <file>": Check out a previous version of a file. This turns the <file> that resides in the working directory into an exact copy of the one from <commit> and "adds it to the staging area".

checkout branch:
        1. git checkout <existing-branch> : Check out the specified branch, which should have already been created with git branch.

        2. git checkout -b <new-branch>: Create and check out <new-branch>.
        3. git checkout -b <new-branch> <existing-branch>: Same as the above invocation, but base the new branch off of <existing-branch>
        4. git checkout --track origin/<existing-branch>: It will switch to remote branch which is aready part of master branch of remote repository.

Detached HEADs:
	1. If you checkout a commit, it will switch to "detached HEAD".
	2. In detached HEAD you can add the file and commit the file, but you cannot push the changes to Repository. To push the changes you can simply create a branch or move a branch to push the changes to repository.

precautions while branch checkout:
	if your working directory or staging area has uncommitted changes that conflict with the branch you’re checking out, Git won’t let you switch branches. It’s best to have a clean working state when you switch branches. The cleaning can be done using "Stashing and Cleaning".

git merge: The git merge command lets you take the independent lines of development created by git branch and integrate them into a single branch.
--ff
When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge commit. This is the default behavior.

--no-ff
Create a merge commit even when the merge resolves as a fast-forward.

	1. git merge <branch>:  Merge the specified branch into the current branch.
	2. git merge --no-ff <branch> : Merge the specified branch into the current branch, but always generate a merge commit (even if it was a fast-forward merge). This is useful for documenting all merges that occur in your repository. The default behavior of Git is to use fast-forwarding whenever possible. 
	3. git config branch.master.mergeoptions  "--no-ff" this will change default behaviour of merger to --no-ff.
	4. -ff Fast-forward: A fast-forward merge can occur when there is a linear path from the current branch tip to the target branch. i.e Instead of merging the branches, all Git has to do to integrate the histories is move (i.e., “fast forward”) the current branch tip up to the target branch tip. This will not create any merge commit.
	4. 3-Way Merge: This is used in case where master progresses while the feature is in-progress. Used when several developers working on same project.

	5. "git merge --abort": can only be run after the merge has resulted in conflicts. git merge --abort will abort the merge process and try to reconstruct the pre-merge state. 

current branch is "master"
	  A---B---C topic
	 /
    D---E---F---G master

Then "git merge topic" will replay the changes made on the topic branch since it diverged from master (i.e., E) until its current commit (C) on top of master. This will results in new commit along with message of two parent commits and log message from user, master is at H.
	  A---B---C topic
	 /         \
    D---E---F---G---H master


Note: Running git merge with non-trivial uncommitted changes is discouraged.

Merge conflicts:
While merging, amoung the changes made on comman ancestors version, non-overlapping once (i.e you changed the area of file and from other side left the area intact, vice-versa) are incorporated to final results.

Example: if any changes from remote repo, with the help of fetch we can get the remote commit ID.
	git fetch : this command gets the remote commit ID of latest commit made on remote repo.
	From https://github.com/naveensadanand/notes
	8974bdf..0dc73b8  gitLearning -> origin/gitLearning
	Our branch is at Commit ID: 8974bdf and remote is having at 0dc73b8.
Using git checkout "commitID" command we can simply check the changes made in remote commitID if everything is fine we can merge our remote commits with our commit resulting in new commit ID. This is the example of --no-ff.
	git checkout 0dc73b8 : Head moves to commitID and we can see the changes and decide to merge it or not.
	git checkout branch: Head moves to previous branch.
	git merge: merging both commits and creates merge commit.
	git push: once we say git push, it has created new commit ffac4fc as shown below
To https://github.com/naveensadanand/notes.git
   0dc73b8..ffac4fc  gitLearning -> gitLearning

When both sides made changes to the same area, we need to resolve it manually, we can see conflict chunk like this.
<<<<<<< yours:sample.txt
Conflict resolution is hard;
let's go shopping.
=======
Git makes conflict resolution easy.
>>>>>>> theirs:sample.txt

The area where a pair of conflicting changes happened is marked with markers <<<<<<<, =======, and >>>>>>>. The part before the ======= is typically your side, and the part afterwards is typically their side.

After seeing a conflict, you can do two things:
	1. Decide not to merge. The only clean-ups you need are to reset the index file to the HEAD commit to reverse 2. and to clean up working tree changes made by 2. and 3.; git merge --abort can be used for this.
	2. Resolve the conflicts. Git will mark the conflicts in the working tree. Edit the files into shape and git add them to the index. Use git commit to seal the deal.

command flow:
	git fetch
	git checkout CommitID 
	Check the changes, and try to merge.
	git merge
	At this stage it will throw error for merge conflict.
"
Auto-merging otherfile
CONFLICT (content): Merge conflict in otherfile
Automatic merge failed; fix conflicts and then commit the result.
"
	then open file "otherfile" and resolve conflict, and use commit.

	git add
	git commit
	git push	

git fetch:
	1. Fetch branches and/or tags (collectively, "refs") from one or more other repositories, along with the objects necessary to complete their histories. 
	2. Remote-tracking branches are updated.
-all 
fetches all remotes.

-f or --force
When git fetch is used with <rbranch>:<lbranch> refspec, it refuses to update the local branch <lbranch> unless the remote branch <rbranch> it fetches is a descendant of <lbranch>. 
This option (-f) overrides that check.

<repository>
The "remote" repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section GIT URLS below) or the name of a remote.

CONFIGURED REMOTE-TRACKING BRANCHES:
git fetch allows you to configure remote.<repository>.fetch configuration variables. Typically such a variable may look like this:
[remote "origin"]
	fetch = +refs/heads/*:refs/remotes/origin/*

When git fetch is run without specifying what branches and/or tags to fetch on the command line, e.g. git fetch origin or git fetch, remote.<repository>.fetch values are used as the refspecs—​they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the origin (i.e. any ref that matches the left-hand side of the value, refs/heads/*) and update the corresponding remote-tracking branches in the refs/remotes/origin/* hierarchy.

EX: 
	1. git fetch origin
	The above command copies all branches from the remote refs/heads/ namespace and stores them to the local refs/remotes/origin/ namespace
	2. git fetch origin +pu:pu maint:tmp
	This updates (or creates, as necessary) branches pu and tmp in the local repository by fetching from the branches (respectively) pu and maint from the remote repository.
GIT URLS:
	1. Git supports ssh, git, http, and https protocols  (in addition, ftp, and ftps can be used for fetching, but this is inefficient and deprecated; do not use it).

The following syntaxes may be used with them:
	ssh://[user@]host.xz[:port]/path/to/repo.git/
	git://host.xz[:port]/path/to/repo.git/
	http[s]://host.xz[:port]/path/to/repo.git/
	ftp[s]://host.xz[:port]/path/to/repo.git/
	

git pull:
	1. git pull is shorthand for git fetch followed by git merge FETCH_HEAD to merge the retrieved branch heads into the current branch. With --rebase, it runs git rebase instead of git merge.
Assume the following history exists and the current branch is "master":

	  A---B---C master on origin
	 /
    D---E---F---G master
	^
	origin/master in your repository
Then "git pull" will fetch and replay the changes from the remote master branch since it diverged from the local master (i.e., E) until its current commit (C) on top of master and record the result in a new commit (i.e H) along with the names of the two parent commits and a log message from the user describing the changes.

	  A---B---C origin/master
	 /         \
    D---E---F---G---H master

--ff
When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge commit. 

--no-ff
Create a merge commit even when the merge resolves as a fast-forward. 

-r
--rebase[=false|true|preserve|interactive]
	1. When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.
	2. When set to preserve, rebase with the --preserve-merges option passed to git rebase so that locally created merge commits will not be flattened.
	3. When false, merge the current branch into the upstream branch.
	4. When interactive, enable the interactive mode of rebase.


git remote:

-v or --verbose
	1. show remote url after name.

Add a new remote, fetch, and check out a branch from it.
	cmd: git remote
	o/p: origin
	cmd: git branch -r
	o/p:  	origin/HEAD -> origin/master
		origin/clanguage
		origin/detachHeadCheck
  		origin/gitLearning
  		origin/jenkins
		origin/master
	cmd: git remote add staging git://git.kernel.org/.../gregkh/staging.git 
	Above command will add remote repository git://git.kernel.org/.../gregkh/staging.git with name staging.
	cmd: git remote
	o/p: 	origin
		staging
	cmd: git fetch staging
	o/p: 	From git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
	 * [new branch]      master     -> staging/master
	 * [new branch]      staging-linus -> staging/staging-linus
	 * [new branch]      staging-next -> staging/staging-next
	cmd: git branch -r 
	o/p:   	origin/HEAD -> origin/master
		origin/clanguage
		origin/detachHeadCheck
 		origin/gitLearning
  		origin/jenkins
  		origin/master
		staging/master   Here new branch is coming.
	cmd: git checkout -b staging staging/master
	This will create new branch with origin staging, with this we can work further.

Imitate git clone but track only selected branches

$ mkdir project.git
$ cd project.git
$ git init
$ git remote add -f -t master -m master origin git://example.com/git.git/
$ git merge origin


git rebase:
	git-rebase - Reapply commits on top of another base tip

git rebase [-i | --interactive] [options] [--exec <cmd>] [--onto <newbase>]
	[<upstream> [<branch>]]
git rebase [-i | --interactive] [options] [--exec <cmd>] [--onto <newbase>]
	--root [<branch>]
git rebase --continue | --skip | --abort | --edit-todo

	2. <branch> Working branch; defaults to HEAD. If <branch> is specified, git rebase will perform an automatic git checkout <branch> before doing anything else. Otherwise it remains on the current branch.
	3. <upstream>: Upstream branch to compare against. If <upstream> is not specified, the upstream configured in branch.<name>.remote and branch.<name>.merge options will be used and the --fork-point option is assumed. If you are not on any branch and current branch not configured upstream then the rebase will abort.
	4. --onto <newbase> Starting point at which to create the new commits. If the --onto option was supplied, the current branch is reset to <upstream>, or <newbase>. This has the exact same effect as git reset --hard <upstream> (or <newbase>).
	5. All changes made by commits in the current branch but that are not in <upstream> are saved to a temporary area. This is the same set of commits that would be shown by git log <upstream>..HEAD
	6. The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order. 
	7. It is possible that a merge failure will prevent this process from being completely automatic.
	8. After resolving merge failure, we can use command "git rebase --continue"
	9. "git rebase --skip" command can bypass merge failure.
	10. "git rebase --abort": command can be used to checkout original <branch> and remove the .git/rebase-apply working files.
	11. --continue Restart the rebasing process after having resolved a merge conflict.
	12. --no-ff With --interactive, cherry-pick all rebased commits instead of fast-forwarding over the unchanged ones. This ensures that the entire history of the rebased branch is composed of new commits.
	13. --autostash --no-autostash: Automatically create a temporary stash before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts.
	14. --root: Rebase all commits reachable from <branch>, instead of limiting them with an <upstream>. This allows you to rebase the root commit(s) on a branch. 


current branch is "topic": As per below graph, topic was branched out from master E, and since both are in progress master is at G and topic is at C.

          A---B---C topic
         /
    D---E---F---G master

git rebase master
git rebase master topic  (combination of git checkout topic and git checkout master).
After running any of above command result would be:
                  A'--B'--C' topic
                 /
    D---E---F---G master
Here the topic now is rebase to master G.
Note: When rebase exit topic will remain the checked-out branch.

rebase --onto
	1. First let’s assume your topic is based on branch next. For example, a feature developed in topic depends on some functionality which is found in next.

    o---o---o---o---o  master
         \
          o---o---o---o---o  next
                           \
                            o---o---o  topic

	2. We want to make topic forked from branch master; for example, because the functionality on which topic depends was merged into the more stable master branch.
    o---o---o---o---o  master
        |            \
        |             o'--o'--o'  topic
         \
          o---o---o---o---o  next

We can get this using the following command:
git rebase --onto master next topic

--onto option is to rebase part of a branch. If we have the following situation:

                            H---I---J topicB
                           /
                  E---F---G  topicA
                 /
    A---B---C---D  master
then the command

git rebase --onto master topicA topicB
would result in:

                 H'--I'--J'  topicB
                /
                | E---F---G  topicA
                |/
    A---B---C---D  master
This is useful when topicB does not depend on topicA.

A range of commits could also be removed with rebase.
	1. A range of commit can be removed using rebase.
	if you have E---F---G---H---I---J  topicA and you want to remove F and G, then use below command
	git rebase --onto topic~5 topic~3 topicA
	Above command results in  E---H'---I'---J'  topicA

conflict case:
	1. You can use git diff to locate the markers (<<<<<<) and make edits to resolve the conflict. For each file you edit, you need to tell Git that the conflict has been resolved, typically this would be done with "git add <filename>"
	2. After resolving the conflict manually and updating the index with the desired resolution, you can continue the rebasing process with "git rebase --continue"
	3. you can undo the git rebase with "git rebase --abort"



What is the difference between merge and rebase?
Merge:
current branch is "master"
          A---B---C topic
         /
    D---E---F---G master

Then "git merge topic" will replay the changes made on the topic branch since it diverged from master (i.e., E) until its current commit (C) on top of master. This will results in new commit along with message of two parent commits and log message from user, master is at H.

Here performs a three-way merge between the two latest branch snapshots (G and C) and the most recent common ancestor of the two (E), creating a new snapshot (and commit) H.
          A---B---C topic
         /         \
    D---E---F---G---H master

$ git checkout master
$ git merge experiment

rebase:
However, there is another way: you can take the patch of the change that was introduced in C and reapply it on top of G.

        A---B---C topic
                 \
     D---E---F---G 
		   master
In this example, you’d run the following:
$ git checkout experiment
$ git rebase master
At this point, you can go back to the master branch and do a fast-forward merge.
$ git checkout master
$ git merge experiment
	
		Master
          A---B---C' topic
                   \
    D---E---F---G---H 
                   
Now, the snapshot pointed to by C' is exactly the same as the one that was pointed to by H in the above merge example. Here both master and topic branch pointing to C'.


There is no difference in the end product of the integration, but rebasing makes for a cleaner history. If you examine the log of a rebased branch, it looks like a linear history: it appears that all the work happened in series, even when it originally happened in parallel. Often, you’ll do this to make sure your commits apply cleanly on a remote branch.

More Interesting Rebases:
You branched a topic branch (server) to add some server-side functionality to your project, and made a commit. Then, you branched off that to make the client-side changes (client) and committed a few times. Finally, you went back to your server branch and did a few more commits.

	     	     Master
C1 <-- C2 <-- C5 <-- C6
      \
      C3 <-- C4 <-- C10
       \	   Server
	C8 <-- C9
	      Client
Figure: A history with a topic branch(C8) off another topic branch(C3).
Suppose you decide that you want to merge your client-side changes into your mainline for a release, but you want to hold off on the server-side changes until it’s tested further. 
You can take changes of clinet C8 and C9 which is not present in Server, and replay them on your master branch by using the --onto option of git rebase:

$ git rebase --onto master server client
This basically says, “Take the client branch, figure out the patches since it diverged from the server branch, and replay these patches in the client branch to master.

                     Master
C1 <-- C2 <-- C5 <-- C6 <-- C8' <-- C9'
      \				   Client
      C3 <-- C4 <-- C10
       \           Server

Figure: Rebasing a topic branch(C8) off another topic branch(C3).

Now you can fast-forward your master branch:
$ git checkout master
$ git merge client
 		                   Master
C1 <-- C2 <-- C5 <-- C6 <-- C8' <-- C9'
      \                            Client
      C3 <-- C4 <-- C10
       \           Server

Figure. Fast-forwarding your master branch to include the client branch changes


Let’s say you decide to pull in your server branch as well. 
ou can rebase the server branch onto the master branch without having to check it out first by running git rebase [basebranch] [topicbranch] – which checks out the topic branch (in this case, server) for you and replays it onto the base branch (master):

$ git rebase master server   #This command equals to "git checkout server" and "git rebase master"

This replays your server work on top of your master work.

                                   Master
C1 <-- C2 <-- C5 <-- C6 <-- C8' <-- C9' <-- C3' <-- C4' <-- C10'
      \                            Client    		   server

Figure. Rebasing your server branch on top of your master branch

Then, you can fast-forward the base branch (master):

$ git checkout master
$ git merge server

You can remove the client and server branches.
$ git branch -d client
$ git branch -d server

                                   			   Master
C1 <-- C2 <-- C5 <-- C6 <-- C8' <-- C9' <-- C3' <-- C4' <-- C10'

Figure. Final commit history

Note: Do not rebase commits that exist outside your repository.
In general the way to get the best of both worlds is to rebase local changes you’ve made but haven’t shared yet before you push them in order to clean up your story, but never rebase anything you’ve pushed somewhere. 
You should also be able to share your branches by pushing them to a shared server, working with others on shared branches and rebasing your branches before they are shared.

git stash:
	1. Use git stash when you want to record the current state of the working directory and the index, but want to go back to a clean working directory.
	Calling git stash without any arguments is equivalent to git stash save.
	2. Note that the stash is local to your Git repository.
        3. "git stash list": List the stashes that you currently have. Its also list the name of branch, and commitID with commit message.
        stash@{0}: WIP on newbranch: eefbdc0 file5

git stash pop
        Popping your stash removes the changes from your stash and reapplies them to your working copy.
git stash apply
        You can reapply the changes to your working copy and keep them in your stash with "git stash apply". This is useful if you want to apply the same stashed changes to multiple branches.

Stashing untracked or ignored files:
a. By default, running git stash will stash.
        1. changes that have been added to your index (staged changes)
        2. changes made to files that are currently tracked by Git (unstaged changes).
b. But it will not stash:
        1. New files in your working copy that have not yet been staged.
        2. Files that have been ignored.

Adding the -u option (or --include-untracked) tells git stash to also stash your untracked files:

"git stash -u"  or  "git stash --include-untracked"

You can include changes to ignored files as well by passing the -a option (or --all) when running git stash.

"git stash -a" or "git stash -all"

Managing multiple stashes
        1. We can create stash several times to create multiple stashes, can can be view by command "git stash list".
        2. It's good practice to annotate your stashes with a description, using git stash save "message for readability":

$ git stash save "add style to our site"
Saved working directory and index state On master: add style to our site
HEAD is now at 5002d47 our new homepage

$ git stash list
stash@{0}: On master: add style to our site
stash@{1}: WIP on master: 5002d47 our new homepage
stash@{2}: WIP on master: 5002d47 our new homepage

By default, git stash pop will re-apply the most recently created stash: stash@{0}
You can choose which stash to re-apply by passing its identifier as the last argument, for example:
$ git stash pop stash@{2}


Viewing stash diffs:
        1. "git stash show": You can view a summary of a stash with "git stash show".
        2. Or pass the -p option (or --patch) to view the full diff of a stash "git stash -p" or "git stash --patch". You can also use this command to choose to stash just a single file, a collection of files, or individual changes from within files.

Cleaning up your stash:
        1. You can delete it with "git stash drop".
        2. You can delete all of your stashes using command "git stash clear"


.gitignore
Git sees every file in your working copy as one of three things:
        1. tracked - a file which has been previously staged or committed;
        2. untracked - a file which has not been staged or committed; or
        3. ignored - a file which Git has been explicitly told to ignore.
You can add file manually.
vi ~/.gitignore
# ignore all logs
*.log
#ignore object files
*.o
#ignore .gitignore file in local repository.
.gitignore

Ignored files are usually build artifacts and machine generated files that can be derived from your repository source or should otherwise not be committed.
Some common examples are:
        1. dependency caches, such as the contents of /node_modules or /packages
        2. compiled code, such as .o, .pyc, and .class files
        3. build output directories, such as /bin, /out, or /target
        4. files generated at runtime, such as .log, .lock, or .tmp
        5. hidden system files, such as .DS_Store or Thumbs.db
        6. personal IDE config files, such as .idea/workspace.xml

.gitignore file can be created locally. This will ignore file for your local repository you are working on.


Global Git ignore rules:
        In addition, you can define global Git ignore patterns for all repositories on your local system by setting the Git core.excludesFile property.
        "git config --global core.excludesFile ~/.gitignore" This command will add rule to excludesFile from /home/naveen/.gitignore

Ignoring a previously committed file:
        1. If you want to ignore a file that you've committed in the past, you'll need to delete the file from your repository and then add a .gitignore rule for it.
        2. Using the --cached option with git rm means that the file will be deleted from your repository history, but will remain in your working directory as an ignored file.

Example:
$ echo debug.log >> .gitignore

$ git rm --cached debug.log
rm 'debug.log'

$ git commit -m "Start ignoring debug.log"
Note: You can omit the --cached option if you want to delete the file from both the repository and your local file system.

Committing an ignored file:
        1. We have a pattern called .log in .gitignore file, but is you want to commit build.log file, you can give exception to build.log file in .gitignore file.
This can be achieve by two ways using -f option to add a file and we can give negation in .gitignore file.

        Example1: git add -f debug.log
                  git commit -m "Force adding debug.log"

        Example2: open .gitignore file and add !debug.log, with this you can do normal commit.
                git add debug.log
                git commit -m "Adding debug.log"
.gitignore and stash:
        1. by default git stash ignores ignored files and only stashes changes to files that are tracked by Git. However, you can invoke git stash with the --all option to stash changes to ignored and untracked files as well.

Debugging .gitignore files:
        1. If you have complicated .gitignore patterns, or patterns spread over multiple .gitignore files, it can be difficult to track down "why a particular file is being ignored".
        2. You can use the git check-ignore command with the -v (or --verbose) option to determine which pattern is causing a particular file to be ignored:
        "<file containing the pattern> : <line number of the pattern> : <pattern>    <file name>"
Example: "git check-ignore -v debug.log"
        .gitignore:3:*.log  debug.log


git clone
git clone <repo> <dir>
	1. Clones a repository into a newly created directory, creates remote-tracking branches for each branch in the cloned repository (visible using git branch -r), and creates and checks out an initial branch that is forked from the cloned repository’s currently active branch.
	2. After clone a plain git fetch without arguments will update all the remote-tracking branches, and a git pull without arguments will in addition merge the remote master branch into the current master branch.
	step1: git clone URL <dir> #this command creates a directory <dir> and clone the remote repository through URL into the <dir>.
	step2: git fetch: This command without arguments will update all the remote-tracking branches.
	step3: git pull: This command without arguments will in addition merge the remote master branch into the current master branch.
	3. While cloning if we give "--single-branch" then it will clone only master branch, so step2 and step3 can be ignored.

-l or --local
When the repository to clone from is on a local machine.
If the repository is specified as a local path (e.g., /path/to/repo), this is the default.
If the repository is specified as a URL, then this flag is ignored 

If the reference repository is on the local machine, automatically setup .git/objects/info/alternates to obtain objects from the reference repository. Using an already existing repository as an alternate will require fewer objects to be copied from the repository being cloned, reducing network and local storage costs.

GIT URLS
In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent.
The following syntaxes may be used with them:

ssh://[user@]host.xz[:port]/path/to/repo.git/

git://host.xz[:port]/path/to/repo.git/

http[s]://host.xz[:port]/path/to/repo.git/

ftp[s]://host.xz[:port]/path/to/repo.git/

Examples:
Clone from upstream:
$ git clone git://git.kernel.org/pub/scm/.../linux.git my-linux
$ cd my-linux
$ make


Make a local clone that borrows from the current directory, without checking things out:
$ git clone -l -s -n . ../copy
$ cd ../copy
$ git show-branch

Clone from upstream while borrowing from an existing local directory:

$ git clone --reference /git/linux.git 	git://git.kernel.org/pub/scm/.../linux.git my-linux
$ cd my-linux

Create a bare repository to publish your changes to the public:
$ git clone --bare -l /home/proj/.git /pub/scm/proj.git

git revert:
	1.  git revert is used to record some new commits to reverse the effect of some earlier commits.
-e or --edit
	With this option, git revert will let you edit the commit message prior to committing the revert.
--continue
Continue the operation in progress using the information in .git/sequencer. Can be used to continue after resolving conflicts in a failed cherry-pick or revert.
--quit
Forget about the current operation in progress. Can be used to clear the sequencer state after a failed cherry-pick or revert.
--abort
Cancel the operation and return to the pre-sequence state.

EXAMPLES
git revert HEAD~3
	Revert the changes specified by the fourth last commit in HEAD and create a new commit with the reverted changes.

git revert -n master~5..master~2
	Revert the changes done by commits from the fifth last commit in master (included) to the third last commit in master (included), but do not create any commit with the reverted changes. The revert only modifies the working tree and the index.

git revert <commit>
        1. Generate a new commit that undoes all of the changes introduced in <commit>, then apply it to the current branch.
        2. This can be useful, for example, if you’re tracking down a bug and find that it was introduced by a single commit. Instead of manually going in, fixing it, and committing a new snapshot, you can use git revert to automatically do all of this for you.

git revert HEAD
	Revert the commit we just created.

