Reference: https://www.atlassian.com/git/tutorials/learn-git-with-bitbucket-cloud/
GIT Topics.
1. init, add, commit, push, pull, branch, checkout.
2. remote
3. clone
4. fetch
5. merge
6. stash
7. revert
8. rebase
9. reset
10. squash
11. cherry pick

What is Version Control System?
	Version control systems are a category of software tools that help a software team manage changes to source code over time. 

What is Git?
	Git is a Distributed VCS, a category known as DVCS
	Git is a software which keeps track of changes that you make in files and directory.
-especially test changes, 
-version 1, version 2, version 3
git can track/manager above version, can allow you to move back and forth version also allows you to check diff between those versions.

Since it manages versions, so it also called Version control system (VCS).

VCS can be used to Source code management (SCM).

Performance

The raw performance characteristics of Git are very strong when compared to many alternatives. Committing new changes, branching, merging and comparing past versions are all optimized for performance. 

Git is distributed Version control.
--Different users (or teams of users) each maintain their own repositories, instead of working from central repository.
--changes are stored as "change sets" or "patches"
	-focus on tracking changes not version of the documents.
	-different from CVS and SVN, which track versions to versions.
	-change sets can be exchanged between repositories.
		-"merge-in change sets" or "apply patches"
--No single master repository, just many working copies
	-Each with their own combination of change sets.
--Imagine changes to a document as sets A,B,C,D,E,F
	-Repo 1: A,B,C,D,E,F
	-Repo 2: A,B,C,D
	-Repo 3: A,B,C,E
	-Repo 4: A,B,E,F
--No need to communicate with a central server
	-faster (communication is not required with a central server)
	-no network access required (since we are not making any communication with server).

Git Repository URL:
The user the_best has a repository called awesome_repo, the URL for that repository would be https://bitbucket.org/the_best/awesome_repo.
A private repository is only visible to you and those you give access to.

git init:
It initialiZes git project, it will create hidden .git directory.

This will make set-up home for git repository and track all files changes in this directory (.git directory).

commands and explanation.
1. git init
	a. It initialiZes git project, it will create hidden .git directory.
	b. By default it will create branch with the name master.
git init <directory>
Create an empty Git repository in the specified directory. Running this command will create a new folder called <directory containing nothing but the .git subdirectory.

git init --bare <directory> This command creates a bare repository.
What is bare repository?
The --bare flag creates a repository that doesn’t have a working directory, making it impossible to edit files and commit changes in that repository.
Central repositories should always be created as bare repositories because pushing branches to a non-bare repository has the potential to overwrite changes.
Think of --bare as a way to mark a repository as a storage facility, opposed to a development environment. This means that for virtually all Git workflows, the central repository is bare, and developers local repositories are non-bare.
EXample: 
step 1: ssh <user>@<host> 	: First, you SSH into the server that will contain your central repository. 
step 2: cd path/above/repo 	: Then, you navigate to wherever you’d like to store the project.
step 3: git init --bare my-project.git : use the --bare flag to create a central storage repository. 
Now Developers would then [clone](/tutorials/setting-up-a-repository/git-clone) my-project.git to create a local copy on their development machine.


git clone:

git clone <repo>
Clone the existing repository located at <repo> onto the local machine. 

git clone <repo> <directory>
Clone the repository located at <repo> into the folder called <directory> on the local machine.

Note: If a project has already been set up in a central repository, the git clone command is the most common way for users to obtain a development copy. 


Repo-To-Repo Collaboration:
Git makes no distinction between the working copy and the central repository—they are all full-fledged Git repositories.
Git’s collaboration model is based on repository-to-repository interaction. Instead of checking a working copy into SVN’s central repository, you push or pull commits from one repository to another another repository.

git config:
1. The git config command lets you configure your Git installation (or an individual repository) from the command line.

2. git config user.name <name>
Define the author name to be used for all commits in the current repository. Typically, you’ll want to use the --global flag to set configuration options for the current user.

3. git config --global user.name <name>
Define the author name to be used for all commits by the current user.

4. git config --global user.email <email>
Define the author email to be used for all commits by the current user.

Note: All configuration options are stored in plaintext files, so the git config command is really just a convenient command-line interface. 

Git stores configuration options in three separate files, which lets you scope options to individual repositories, users, or the entire system:
	1. <repo>/.git/config – Repository-specific settings.
	2. ~/.gitconfig – User-specific settings. This is where options set with the --global flag are stored.
	3. $(prefix)/etc/gitconfig – System-wide settings.
Example: 
# Tell Git who you are
git config --global user.name "John Smith"
git config --global user.email john@example.com

# Select your favorite text editor
git config --global core.editor vim

# Select your favorite text editor
git config --global core.editor vim

# Add some SVN-like aliases
git config --global alias.st status

#git config --global push.default matching
When push.default is set to 'matching', git will push local branches to the remote branches that already exist with the same name.

#git config --global push.default simple 
Git defaults to the more conservative 'simple' behavior, which only pushes the current branch to the corresponding remote branch that 'git pull' uses to update the current branch.

#git config --global core.askpass 
In windows Git will prompt for password while cloning, this will prompt only onetime.

We can see above setting in file vi ~/.gitconfig as shown below.
[user] 
name = John Smith
email = john@example.com
[alias]
st = status
[core]
editor = vim

2. git status: 
	1. The git status command displays the state of the working directory and the staging area. It lets you see which changes have been staged, which haven’t, and which files aren’t being tracked by Git.
	2. Its give information of what's been going on with git add and git commit. Status messages also include relevant instructions for staging/unstaging files. 
	3. It gives the information of the branch to which git is currently pointing to.
	4. It gives the list of information of files which are needs to be get add using "git add". The file is untracked, meaning that Git sees a file not part of a previous commit.
	5. If the file gets added then it will give list of files that needs to be commit "git commit filename".
	6. Merge conflict information.

3. git add
	a. The git add command adds a change in the working directory to the staging area.  It tells Git that you want to include updates to a particular file in the next commit. git add command will not effect local repository with any significant way changes are not actually recorded until you run git commit.
        b. Stage all changes in <directory> for the next commit.
		"git add -p"
Question on git add:
1. Why git add required?
	1. "git add filename" this command add changes to staging area, and commit command picks what's in the staging area.
	2. Git works by using a "staging" area where you prepare what you are going to bundle together as a commit. So, you decided what set of changes you want to commit (e.g. all or a subset), you add them to the staging area, and then you commit what's in the staging area.
	3. If you want to just commit stuff that you've changed, but not include newly created files you can use git commit -a "Comment for modified files already under source control."

2. How do i remove a file from staging area?
	1. "git reset HEAD mynewfile.txt" or "git reset HEAD -- mynewfile.txt" This command will unstage from the staging area. Your modifications will be kept and the file will once again show up in the modified. If you really wants to delete after unstaging, you can use below command.
	2. "git clean -df mynewfile.txt" This command will remove mynewfile.txt from current directory. If you do not provide file name like "git clean -df" this will remove all unstaged file from working directory. So be careful while using "git clean -df" command.



The Staging Area:
a. It as a buffer between the working directory and the project history. The staging area is where you prepare a snapshot of a set of changes before committing them to the official history.

4. git commit: 
The git commit takes the staged snapshot and commits it to the project history
                "git commit -m "my first commit"
	a. It will commit the file to the staging area under particular branch. In general it will create an object.
	b. Its mandatory to give git commit message otherwise it will through below message.	
		"c:\Dropbox\GIT\notes>git commit gitnotes Aborting commit due to empty commit message."
	c. If you are in branch x and you switched to your working branch, and you see below message, then you should add and commit the changes.
"Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)"

		"git commit -a"
Above command with -a, Commit a snapshot of all changes in the working directory. This only includes modifications to tracked files (those that have been added with git add at some point in their history).

Note: SVN(perforce) commit consists of a diff compared to the original file added to the repository. Git, on the other hand, records the entire contents of each file in every commit. This makes many Git operations much faster than SVN, since a particular version of a file doesn’t have to be “assembled” from its diffs—the complete revision of each file is immediately available from Git's internal database.
Question on git commit:
Why git commit required? What is difference between git commit and git push?
a. The git commit command commits the staged snapshot to the project history. Snapshots are committed to the local repository, and this requires absolutely no interaction with other Git repositories.
b. Basically git commit "records changes to the repository" while git push "updates remote refs along with associated objects". So the first one is used in connection with your local repository, while the latter one is used to interact with a remote repository.
		commit: adding changes to the local repository
		push: to transfer the last commit(s) to a remote server

git push:
	"git push origin master"
	Bitbucket using git push origin master. This command specifies that you are pushing to the master branch (the branch on Bitbucket) on origin (the Bitbucket server).
	
	"git push <remote> <branch>"
	Push the specified branch to <remote>, along with all of the necessary commits and internal objects. 

	"git push <remote> --force"
	Same as the above command, but force the push even if it results in a non-fast-forward merge. Do not use the --force flag unless you’re absolutely sure you know what you’re doing.
	The --force flag overrides this behavior and makes the remote repository’s branch match your local one, deleting any upstream changes that may have occurred since you last pulled.

	"git push <remote> --all"
	Push all of your local branches to the specified remote.

	"git push <remote> --tags"
	Tags are not automatically pushed when you push a branch or use the --all option. The --tags flag sends all of your local tags to the remote repository.

Example: 
	First, it makes sure your local master is up-to-date by fetching the central repository’s copy and rebasing your changes on top of them. 
	Then, the git push command sends all of the commits on your local master to the central repository.

	"git checkout master"
	"git fetch origin master"
	"git rebase -i origin/master"
	# Squash commits, fix up commit messages etc.
	"git push origin master"

	Since we already made sure the local master was up-to-date, this should result in a fast-forward merge.


Common practice/process:
	1. Created a branch and checked it out
		git checkout -b <newbranch>
	2. Made a change in the new branch
		git add 
	3. Committed the change to the new branch
		git commit -a
	4. Integrated that change back into the main branch
		git checkout master             #we need to go to master branch(central)
		git merge new-feature           #merge new-feature branch in master.
	5. Deleted the branch you are no longer using.
		git branch -d new-feature       #delete new-feature branch.
	6. push your change to git repository.
		git push origin master 

git pull:
	1. Pull changes from a remote repository.
	2. The git pull command merges the file from your remote repository (Bitbucket) into your local repository with a single command.

Note: We should not use pull blindly, since it will override the changes made locally.

5. git log:
	1. The git log command displays committed snapshots. The git log command is Git's basic tool for exploring a repository’s history.
	2. This command will give detail information of repository. It will give detail information like
commit ID/object, auther, Date and Git commit message as well.

Limiting log:
	Limit the number of commits by <limit>. For example, git log -n 3 will display only 3 commits.
	"git log -n <limit>"
	"git log --oneline" This command will give one line information of each commit message.

	"git log <file>" Only display commits that include the specified file.
	"git log --stat" This command include which files were altered and the relative number of lines that were added or deleted from each of them.
	"git log -p" Display the patch representing each commit. This shows the full diff of each commit.
	"git log --author="<pattern>" " Search for commits by a particular author. The <pattern> argument can be a plain string or a regular expression.
	"git log --grep="<pattern>" " Search for commits with a commit message that matches <pattern>, which can be a plain string or a regular expression.
	"git log <since>..<until>" Show only commits that occur between <since> and <until>. Both arguments can be either a commit ID, a branch name, HEAD, or any other kind of revision reference.

Example:
git log
commit 3157ee3718e180a9476bf2e5cab8e3f1e78a73b7
Author: John Smith

The 40-character string after commit is an SHA-1 checksum of the commit’s contents. This serves two purposes. First, it ensures the integrity of the commit—if it was ever corrupted, the commit would generate a different checksum. Second, it serves as a unique ID for the commit.

The ~ character is useful for making relative references to the parent of a commit. For example, 3157e~1 refers to the commit before 3157e, and HEAD~3 is the great-grandparent of the current commit.

This ID can be used in commands like git log <since>..<until> to refer to specific commits. For instance, git log 3157e..5ab91 will display everything between the commits with ID's 3157e and 5ab91. 

	"git log --author="John Smith" -p hello.py" This will display a full diff of all the changes John Smith has made to the file hello.py.

..
	The .. syntax is a very useful tool for comparing branches. The next example displays a brief overview of all the commits that are in some-feature that are not in master.
	"git log --oneline master..some-feature"

Question: What is difference between git status and git log?
	1. "git status" lets you inspect the working directory and the staging area
	2. "git log" only operates on the committed history.

git stash:
	1. git stash temporarily shelves (or stashes) changes you've made to your working copy so you can work on something else, and then come back and re-apply them later on.

	Stashing your work
		git stash	(command to stash).
	a. The git stash command takes your uncommitted changes (both staged and unstaged), saves them away for later use, and then reverts them from your working copy.
	b. At this point you're free to make changes, create new commits, switch branches, and perform any other Git operations; then come back and re-apply your stash when you're ready.
	c. Note that the stash is local to your Git repository; stashes are not transferred to the server when you push.

git stash pop
	Popping your stash removes the changes from your stash and reapplies them to your working copy.
git stash apply
	You can reapply the changes to your working copy and keep them in your stash with "git stash apply". This is useful if you want to apply the same stashed changes to multiple branches.

Stashing untracked or ignored files: 
a. By default, running git stash will stash.
	1. changes that have been added to your index (staged changes)
	2. changes made to files that are currently tracked by Git (unstaged changes).
b. But it will not stash:
	1. New files in your working copy that have not yet been staged.
	2. Files that have been ignored.

Adding the -u option (or --include-untracked) tells git stash to also stash your untracked files:

"git stash -u"  or  "git stash --include-untracked"

You can include changes to ignored files as well by passing the -a option (or --all) when running git stash.

"git stash -a" or "git stash -all"

Managing multiple stashes
	1. We can create stash several times to create multiple stashes, can can be view by command "git stash list".
	2. It's good practice to annotate your stashes with a description, using git stash save "message for readability":

$ git stash save "add style to our site"
Saved working directory and index state On master: add style to our site
HEAD is now at 5002d47 our new homepage

$ git stash list
stash@{0}: On master: add style to our site
stash@{1}: WIP on master: 5002d47 our new homepage
stash@{2}: WIP on master: 5002d47 our new homepage

By default, git stash pop will re-apply the most recently created stash: stash@{0}
You can choose which stash to re-apply by passing its identifier as the last argument, for example:
$ git stash pop stash@{2}


Viewing stash diffs:
	1. "git stash show": You can view a summary of a stash with "git stash show".
	2. Or pass the -p option (or --patch) to view the full diff of a stash "git stash -p" or "git stash --patch". You can also use this command to choose to stash just a single file, a collection of files, or individual changes from within files.

Cleaning up your stash:
	1. You can delete it with "git stash drop".
	2. You can delete all of your stashes using command "git stash clear"

.gitignore
Git sees every file in your working copy as one of three things:
	1. tracked - a file which has been previously staged or committed;
	2. untracked - a file which has not been staged or committed; or
	3. ignored - a file which Git has been explicitly told to ignore.

Ignored files are usually build artifacts and machine generated files that can be derived from your repository source or should otherwise not be committed.
Some common examples are:
	1. dependency caches, such as the contents of /node_modules or /packages
	2. compiled code, such as .o, .pyc, and .class files
	3. build output directories, such as /bin, /out, or /target
	4. files generated at runtime, such as .log, .lock, or .tmp
	5. hidden system files, such as .DS_Store or Thumbs.db
	6. personal IDE config files, such as .idea/workspace.xml

.gitignore file can be created locally. This will ignore file for your local repository you are working on.


Global Git ignore rules:
	In addition, you can define global Git ignore patterns for all repositories on your local system by setting the Git core.excludesFile property.
	"git config --global core.excludesFile ~/.gitignore"

Ignoring a previously committed file:
	1. If you want to ignore a file that you've committed in the past, you'll need to delete the file from your repository and then add a .gitignore rule for it.
	2. Using the --cached option with git rm means that the file will be deleted from your repository, but will remain in your working directory as an ignored file.

Example:
$ echo debug.log >> .gitignore
  
$ git rm --cached debug.log
rm 'debug.log'
  
$ git commit -m "Start ignoring debug.log"

Note: You can omit the --cached option if you want to delete the file from both the repository and your local file system.

Committing an ignored file: 
	1. We have a patter called .log in .gitignore file, but is you want to commit build.log file, you can give exception to build.log file in .gitignore file.
This can be achieve by two ways using -f option to add a file and we can give negation in .gitignore file.

	Example1: git add -f debug.log
  		  git commit -m "Force adding debug.log"

	Example2: open .gitignore file and add !debug.log, with this you can do normal commit.
		git add debug.log
  		git commit -m "Adding debug.log"
.gitignore and stash:
	1. by default git stash ignores ignored files and only stashes changes to files that are tracked by Git. However, you can invoke git stash with the --all option to stash changes to ignored and untracked files as well.

Debugging .gitignore files:
	1. If you have complicated .gitignore patterns, or patterns spread over multiple .gitignore files, it can be difficult to track down "why a particular file is being ignored".
	2. You can use the git check-ignore command with the -v (or --verbose) option to determine which pattern is causing a particular file to be ignored:
	"<file containing the pattern> : <line number of the pattern> : <pattern>    <file name>"
Example: "git check-ignore -v debug.log"
	.gitignore:3:*.log  debug.log


6.Git branch:  
	1. A branch represents an independent line of development.
	2. The git branch command lets you create, list, rename, and delete branches.
	3. Branches will allow you to update your files and only share the information when you're ready.
	4. Branches are most powerful when you're working on a team. You can work on your own part of a project from your own branch,

	1. command "git branch"
	List all of the branches in your repository.
	2. git branch branchname:
	This command will create new branch named branchname
	3. git branch -d <branch>
	Delete the specified branch. This is a “safe” operation in that Git prevents you from deleting the branch if it has unmerged changes. if the branch hasn’t been merged, the above command will output an error message: "error: The branch 'crazy-experiment' is not fully merged.If you are sure you want to delete it, run 'git branch -D crazy-experiment'"
	4. git branch -D <branch>
	Force delete the specified branch, even if it has unmerged changes. 
     	5. git branch -m <branch>
	Rename the current branch to <branch>.

Deleting Branches
	Once you’ve finished working on a branch and have merged it into the main code base, you’re free to delete the branch without losing any history.

What is the need of branch?
	When you want to add a new feature or fix a bug, you spawn a new branch to encapsulate your changes. This makes sure that unstable code is never committed to the main code base, and it gives you the chance to clean up your feature’s history before merging it into the main branch.

What actually branch is, Is the branch represents a seperate storage or directory of container?
	a. Git stores a branch as a reference to a commit. In this sense, a branch represents the tip of a series of commits—it's not a container for commits. The history for a branch is extrapolated through the commit relationships.
	b. Branches are just pointers to commits. When you create a branch, all Git needs to do is create a new pointer—it doesn’t change the repository in any other way.



7. git checkout
	1. The git checkout command serves three distinct functions: 
	checking out files, checking out commits, and checking out branches. 

checkout commit:
	1. Checking out a commit makes the entire working directory match that commit. This can be used to view an old state of your project without altering your current state in any way. 
	2. "git checkout <commit> <file>" 	Check out a previous version of a file. This turns the <file> that resides in the working directory into an exact copy of the one from <commit> and adds it to the staging area.
	3. "git checkout <commit>"	Update all files in the working directory to match the specified commit. You can use either a commit hash or a tag as the <commit> argument. This will put you in a detached HEAD state.
	4. Checking out an old commit is a read-only operation. The “current” state of your project remains untouched in the master branch.
	5. During the normal course of development, the HEAD usually points to master or some other local branch, but when you check out a previous commit, HEAD no longer points to a branch—it points directly to a commit. This is called a “detached HEAD” state

Example:
	Suppose your project history looks like below, and you want to view "Make some important changes to hello.py" then corresponding ID can be used to checkout
	b7119f2 Continue doing crazy things
	872fa7e Try something crazy
	a1e8fb5 Make some important changes to hello.py
	435b61d Create hello.py
	9773e52 Initial import

	"git checkout a1e8fb5" This makes your working directory match the exact state of the a1e8fb5 commit. You can look at files, compile the project, run tests, and even edit files without worrying about losing the current state of the project.Nothing you do in here will be saved in your repository. To continue developing, you need to get back to the “current” state of your project: "git checkout master" Once you’re back in the master branch, you can use either git revert or git reset to undo any undesired changes.



checkout file:
	1. Checking out a file lets you see an old version of that particular file, leaving the rest of your working directory untouched.
	2. "git checkout a1e8fb5 hello.py" On the other hand, checking out an old file does affect the current state of your repository. You can re-commit the old version in a new snapshot as you would any other file. So, in effect, this usage of git checkout serves as a way to revert back to an old version of an individual file.
	3. If you decide you don’t want to keep the old version, you can check out the most recent version with the following: "git checkout HEAD hello.py"

What is difference between usage of commands "git checkout <commit>" and "git checkout <commit> <file>"?
	"git checkout <commit>": Update all files in the working directory to match the specified commit. This will put you in a detached HEAD state.
	"git checkout <commit> <file>": Check out a previous version of a file. This turns the <file> that resides in the working directory into an exact copy of the one from <commit> and adds it to the staging area.

	The git checkout command lets you navigate between the branches created by git branch.
	1. git checkout <existing-branch>
	Check out the specified branch, which should have already been created with git branch. 

	2. git checkout -b <new-branch>
	Create and check out <new-branch>. 
	3. git checkout -b <new-branch> <existing-branch>
	Same as the above invocation, but base the new branch off of <existing-branch>
	4. git checkout --track origin/<existing-branch>
	It will switch to branch which is aready part of master branch while cloning.

If there is a local changes in current branch and you want to switch to other branch, then it will allow to switch to other branch and through below error.

"error: Your local changes to the following files would be overwritten by checkout:
        gitnotes
Please commit your changes or stash them before you can switch branches.
Aborting"
After commiting we can switch/checkout to other branch without git push, since commit file from other branch will not be appeared in switched branch.




Detached HEADs:
	1. HEAD is Git’s way of referring to the current snapshot. Internally, the git checkout command simply updates the HEAD to point to either the specified branch or commit.
	2. When HEAD points to a branch, Git doesn't complain, but when you check out a commit, it switches into a “detached HEAD” state. This is a warning telling you that everything you’re doing is “detached” from the rest of your project’s development. 
	If you were to start developing a feature while in a detached HEAD state, there would be no branch allowing you to get back to it.
	3. The point is, your development should always take place on a branch—never on a detached HEAD. This makes sure you always have a reference to your new commits. However, if you’re just looking at an old commit, it doesn’t really matter if you’re in a detached HEAD state or not. This makes sure you always have a reference to your new commits. However, if you’re just looking at an old commit, it doesn’t really matter if you’re in a detached HEAD state or not.
	4. If you checkout a commit, it will switch to "detached HEAD", and you made changes and commit the changes and it looks good to be have in repository, then you can simply create a branch or move a branch to push the changes to repository.
	Note: in detached HEAD you can add the file and commit the file, but you cannot push the changes to Repository,i.e: when you make changes and commit them, these changes do NOT belong to any branch. if you want to push changes above is the procedure.


Branching example:
git checkout new-feature
Then, you can commit new snapshots.

# Edit some files
git add <file>
git commit -m "Started work on a new feature"
All of these commits are recorded in new-feature, which is completely isolated from master.
When it’s time to get back to “official” code base, simply check out the master branch:
git checkout master
From here (i.e master branch), you have the option to merge in the completed feature, branch off a brand new, unrelated feature, or do some work with the stable version of your project.


8. git merge: The git merge command lets you take the independent lines of development created by git branch and integrate them into a single branch.
	1. git merge <branch>
	Merge the specified branch into the current branch.
	2. git merge --no-ff <branch>
	Merge the specified branch into the current branch, but always generate a merge commit (even if it was a fast-forward merge). This is useful for documenting all merges that occur in your repository.

Fast-forward:
	3. A fast-forward merge can occur when there is a linear path from the current branch tip to the target branch. i.e Instead of merging the branches, all Git has to do to integrate the histories is move (i.e., “fast forward”) the current branch tip up to the target branch tip.
	4. A fast-forward merge is not possible if the branches have diverged. When there is not a linear path to the target branch, Git has no choice but to combine them via a 3-way merge.

# Start a new feature, below command will create new branch <new-feature> from master as base.
git checkout -b new-feature master

# Edit some files
git add <file>
git commit -m "Start a feature"

# Edit some files
git add <file>
git commit -m "Finish a feature"

# Merge in the new-feature branch,
git checkout master		#we need to go to master branch(central)
git merge new-feature   	#merge new-feature branch in master.
git branch -d new-feature	#delete new-feature branch.

3-Way Merge:
	5. When there is not a linear path to the target branch, Git has no choice but to combine them via a 3-way merge. 3-way merger is required in non-linear path i.e both master and tip current branch are in progress parallely.
	6. The nomenclature comes from the fact that Git uses three commits to generate the merge commit: the two branch tips and their common ancestor.
	7. 3-Way Merge is used in long-run projects or several developers working on same project, while fast-forward is used in small features or bug fixes.


# Start a new feature
git checkout -b new-feature master

# Edit some files
git add <file>
git commit -m "Start a feature"

# Edit some files
git add <file>
git commit -m "Finish a feature"

# Develop the master branch
git checkout master

# Edit some files
git add <file>
git commit -m "Make some super-stable changes to master"

# Merge in the new-feature branch
git merge new-feature
git branch -d new-feature

Resolving Conflicts
	1. If the two branches you're trying to merge both changed the same part of the same file, Git won't be able to figure out which version to use. 
	2. When you encounter a merge conflict, running the git status command shows you which files need to be resolved.
For example, if both branches modified the same section of hello.py, you would see something like the following:

# On branch master
# Unmerged paths:
# (use "git add/rm ..." as appropriate to mark resolution)
#
# both modified: hello.py
#
Then, you can go in and fix up the merge to your liking. When you're ready to finish the merge, all you have to do is run git add on the conflicted file(s) to tell Git they're resolved. Then, you run a normal git commit to generate the merge commit.


a. Creating an edit collision:
This is the most common type of conflict. It happens when two branches have changed the same part of the same file, and then those branches are merged together. For example, if you make a change on a particular line in a file, and your colleague working in a repository makes a change on the exact same line, a merge conflict occurs. Git has trouble understanding which change should be used, so it asks you to help out.
When this sort of conflict occurs, Git writes a special block into the file that contains the contents of both versions where the conflict occurred. To complete this type of merge, use your text editor to resolve the conflict, then add the file and commit it to complete the merge.

 In branch-a, you wrote the word "nine," but your friend wrote "eight." Git automatically adds conflict markers to the affected areas. A conflict-marked area begins with <<<<<<< and ends with >>>>>>>. These are also known as the conflict markers. The two conflicting blocks themselves are divided by a =======.
You have several options here. You can either keep your changes, take your friend's changes, or make a brand new change. Whatever you do, you need to make sure to resolve the conflict such that the file makes sense, and everyone is happy.

In this case, you'll put in a whole new version of the line that reflects what happened. The goal is to get the file to look exactly how you want it. You'll delete the conflict markers, and just type out a new change:

b. Resolving a removed file conflict:
Removed file conflicts occur when one person edits a file, and another person deletes that file in their branch. Git does not know if you want to keep the file with the new edits, or delete the file and forget about those edits. 
To deal with this case, we do below scenario.
	1. Keeping the edited file: First, you'll resolve the conflict by keeping the new changes. Suppose that you added a line to your README.md in branch-b, but someone else has deleted the file entirely in branch-c. Git declares the following conflict:
"CONFLICT (modify/delete): README.md deleted in HEAD and modified in branch-b. Version branch-b of README.md left in tree.
Automatic merge failed; fix conflicts and then commit the result."
	Solution: You can resolve this by adding the file back, and committing it once more:
	2. Resolving by removing the file: Now, you'll resolve that conflict the opposite way: by leaving the file deleted. Again, with a merge conflict, Git declares:
"CONFLICT (modify/delete): README.md deleted in HEAD and modified in branch-c. Version branch-c of README.md left in tree.
Automatic merge failed; fix conflicts and then commit the result."
	Solution: Now, you want to remove the file, so do that with the git rm command:
	so commit it with the default message:

git revert:
	git revert <commit>
	1. Generate a new commit that undoes all of the changes introduced in <commit>, then apply it to the current branch.
	2. This can be useful, for example, if you’re tracking down a bug and find that it was introduced by a single commit. Instead of manually going in, fixing it, and committing a new snapshot, you can use git revert to automatically do all of this for you.

Example:
It commits a snapshot, then immediately undoes it with a revert.

# Edit some tracked files

# Commit a snapshot
git commit -m "Make some changes that will be undone"

# Revert the commit we just created.
git revert HEAD 


git reset
	1. If git revert is a “safe” way to undo changes, you can think of git reset as the dangerous method.
	2. When you undo with git reset(and the commits are no longer referenced by any ref or the reflog), there is no way to retrieve the original copy—it is a permanent undo. 

	"git reset <file>"
	Remove the specified file from the staging area, but leave the working directory unchanged. 
	"git reset"
	Reset the staging area to match the most recent commit, but leave the working directory unchanged, This unstages all files without overwriting any changes, giving you the opportunity to re-build the staged snapshot from scratch.
	"git reset --hard"
	Reset the staging area and the working directory to match the most recent commit. In addition to unstaging changes, the --hard flag tells Git to overwrite all changes in the working directory,too.

	"git reset <commit>"
	Move the current branch tip backward to <commit>, reset the staging area to match, but leave the working directory alone.
	"git reset --hard <commit>"
	Move the current branch tip backward to <commit> and reset both the staging area and the working directory to match.

Examples:
Unstaging a File
# Edit both hello.py and main.py

# Stage everything in the current directory
git add .

# Realize that the changes in hello.py and main.py
# should be committed in different snapshots

# Unstage main.py
git reset main.py

# Commit only hello.py
git commit -m "Make some changes to hello.py"

# Commit main.py in a separate snapshot
git add main.py
git commit -m "Edit main.py"


Removing Local Commits
# Create a new file called `foo.py` and add some code to it

# Commit it to the project history
git add foo.py
git commit -m "Start developing a crazy feature"

# Edit `foo.py` again and change some other tracked files, too

# Commit another snapshot
git commit -a -m "Continue my crazy feature"

# Decide to scrap the feature and remove the associated commits
git reset --hard HEAD~2

The git reset HEAD~2 command moves the current branch backward by two commits, effectively removing the two snapshots we just created from the project history.



git clean

The git clean command removes untracked files from your working directory.

	"git clean -n"
	This will show you which files are going to be removed without actually doing it, i.e it will not remove.
	"git clean -f"
	Remove untracked files from the current directory. The -f (force) flag is required unless the clean.requireForce configuration option is set to false (it's true by default).
	This will not remove untracked folders or files specified by .gitignore.
	"git clean -f <path>"
	Remove untracked files, but limit the operation to the specified path.
	"git clean -df"
	Remove untracked files and untracked directories from the current directory.
	"git clean -xf"
	Remove untracked files from the current directory as well as any files that Git usually ignores.

Note: The git clean command can also be useful for cleaning up the working directory after a build. For example, it can easily remove the .o and .exe binaries generated by a C compiler. This is occasionally a necessary step before packaging a project for release. The -x option is particularly convenient for this purpose.

Example:
# Edit some existing files
# Add some new files
# Realize you have no idea what you're doing

# Undo changes in tracked files
git reset --hard

# Remove untracked files
git clean -df
After running this reset/clean sequence, the working directory and the staging area will look exactly like the most recent commit, and git status will report a clean working directory. You're now ready to begin again.



git remote:
	The git remote command lets you create, view, and delete connections to other repositories

	"git remote"
	List the remote connections you have to other repositories.
	"git remote -v"
	Same as the above command, but include the URL of each connection.
	git remote add <name> <url>
	Create a new connection to a remote repository. After adding a remote, you’ll be able to use <name> as a convenient shortcut for <url> in other Git commands.
	"git remote rm <name>"
	Remove the connection to the remote repository called <name>.
	"git remote rename <old-name> <new-name>"
	Rename a remote connection from <old-name> to <new-name>.

Example:
	If your co-worker, John, maintained a publicly accessible repository on dev.example.com/john.git, you could add a connection as follows:
	"git remote add john http://dev.example.com/john.git"
	Having this kind of access to individual developers’ repositories makes it possible to collaborate outside of the central repository. This can be very useful for small teams working on a large project.

By default, if you clone central repository from git hub, origin referred has remote repository and master referred as defualt branch.


As you probably know, git is a distributed version control system. Most operations are done locally. To communicate with the outside world, git uses what are called remotes. These are repositories other than the one on your local disk which you can push your changes into (so that other people can see them) or pull from (so that you can get others changes). The command git remote add origin git@github.com:peter/first_app.git creates a new remote called origin located at git@github.com:peter/first_app.git. Once you do this, in your push commands, you can push to origin instead of typing out the whole URL.

remote = remote repository. Stuff that's on your hard drive is local. Stuff that's on GitHub's server is remote. origin = the default name of the remote repository on GitHub corresponding to the repo you're currently in on your machine. master = the default name of the initial branch of a repository. So, "origin master" is the default branch of your repository on GitHub. That's why you do git push origin master to update GitHub based on the changes you committed locally.

git fetch
	Git fetch just updates your repo data, Fetch branches and/or tags (collectively, "refs") from one or more other repositories, along with the objects necessary to complete their histories.

	1. The git fetch command imports commits from a remote repository into your local repo.
	2. The imported commits are stored as remote branches instead of the normal local branches that we’ve been working with. This gives you a chance to review changes before integrating them into your copy of the project.

	"git fetch <remote>"
	Fetch all of the branches from the repository. This also downloads all of the required commits and files from the other repository.
	"git fetch <remote> <branch>"
	Same as the above command, but only fetch the specified branch.

	3. Fetching is what you do when you want to see what everybody else has been working on. Since fetched content is represented as a remote branch, it has absolutely no effect on your local development work. This makes fetching a safe way to review commits before integrating them with your local repository.

Remote Branches
	Remote branches are just like local branches, except they represent commits from somebody else’s repository. You can check out a remote branch just like a local one, but this puts you in a detached HEAD state (just like checking out an old commit). You can think of them as read-only branches
	"git branch -r"
	To view your remote branches,Remote branches are prefixed by the remote they belong to so that you don’t mix them up with local branches. Again, you can inspect these branches with the usual git checkout and git log commands.

Example of fetch:
git fetch origin
This will display the branches that were downloaded:

a1e8fb5..45e66a4 master -> origin/master
a1e8fb5..9e8ab1c develop -> origin/develop
* [new branch] some-feature -> origin/some-feature

	"git log --oneline master..origin/master"
	To see what commits have been added to the upstream master, you can run a git log using origin/master as a filter.

	To approve the changes and merge them into your local master branch with the following commands:
	git checkout master
	git log origin/master
	Then we can use git merge origin/master
	git merge origin/master
	The origin/master and master branches now point to the same commit, and you are synchronized with the upstream developments.

10. git clone:
command: git clone git@github.com:whatever .
The "." at the end specifies the current folder as the checkout folder.	
Note; If that directory is not empty, this doesn't work.
so you don't want to run "git init" in this folder before cloning into it. But if you did, then removing the .git folder before cloning will do the trick

go into folder.. if folder is empty, then

git clone git@github.com:whatever .
else

git init
git remote add origin PATH/TO/REPO
git fetch
git checkout -t origin/master


12. git pull
	git pull equals to git fetch followed by git merge.

	"git pull <remote>"
	Fetch the specified remote’s copy of the current branch and immediately merge it into the local copy.

	"git pull --rebase <remote>"
	Same as the above command, but instead of using git merge to integrate the remote branch with the local one, use git rebase.
	The --rebase option can be used to ensure a linear history by preventing unnecessary merge commits. Many developers prefer rebasing over merging, since it’s like saying, "I want to put my changes on top of what everybody else has done." 

	if we set "git config --global branch.autosetuprebase always" in config file.
	After running that command, all git pull commands will integrate via git rebase instead of git merge.
Example:
	"git checkout master"
	"git pull --rebase origin"
	This simply moves your local changes onto the top of what everybody else has already contributed.




Question: Difference between fetch and pull?

a. In the simplest terms, git pull does a git fetch followed by a git merge.
You can do a git fetch at any time to update your remote-tracking branches under refs/remotes/<remote>/. This operation never changes any of your own local branches under refs/heads, and is safe to do without changing your working copy.

A git pull is what you would do to bring a local branch up-to-date with its remote version, while also updating your other remote-tracking branches.

When you use pull, Git tries to automatically do your work for you. It is context sensitive, so Git will merge any pulled commits into the branch you are currently working in.  pull automatically merges the commits without letting you review them first. If you dont closely manage your branches, you may run into frequent conflicts.
When you fetch, Git gathers any commits from the target branch that do not exist in your current branch and stores them in your local repository. However, it does not merge them with your current branch. This is particularly useful if you need to keep your repository up to date, but are working on something that might break if you update your files. To integrate the commits into your master branch, you use merge.

Link: https://longair.net/blog/2009/04/16/git-fetch-and-merge/

Note: Dont use git pull, use git fetch and then git merge.
The other problem is that by both fetching and merging in one command, your working directory is updated without giving you a chance to examine the changes youve just brought into your repository. 




Forking
When you work with another user's public Bitbucket repository, typically you have read access to the code but not write access. This is where the concept of forking comes in. Here's how it works:

	1. Fork the repository to copy it to your own account.
	2. Fork thClone the forked repository from Bitbucket to your local system.
	3. Fork thMake changes to the local repository.
	4. Fork thPush the changes to your forked repository on Bitbucket.
	5. Fork thCreate a pull request from the original repository you forked to add the changes you made.
	6. Fork thWait for the repository owner to accept or reject your changes.

If a repository owner accepts the pull request, Bitbucket merges your code changes into the original repository.
